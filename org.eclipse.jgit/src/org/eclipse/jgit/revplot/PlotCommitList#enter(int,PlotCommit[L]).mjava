	@Override
	protected void enter(final int index, final PlotCommit<L> currCommit) {
		setupChildren(currCommit);

		final int nChildren = currCommit.getChildCount();
		if (nChildren == 0)
			return;

		if (nChildren == 1 && currCommit.children[0].getParentCount() < 2) {
			// Only one child, child has only us as their parent.
			// Stay in the same lane as the child.
			//
			final PlotCommit c = currCommit.children[0];
			if (c.lane == null) {
				// Hmmph. This child must be the first along this lane.
				//
				c.lane = nextFreeLane();
				activeLanes.add(c.lane);
			}

			for (int r = index - 1; r >= 0; r--) {
				final PlotCommit rObj = get(r);
				if (rObj == c)
					break;
				rObj.addPassingLane(c.lane);
			}
			currCommit.lane = c.lane;
			currCommit.lane.parent = currCommit;
		} else {
			// More than one child, or our child is a merge.
			// Use a different lane.
			//

			for (int i = 0; i < nChildren; i++) {
				final PlotCommit c = currCommit.children[i];
				if (activeLanes.remove(c.lane)) {
					recycleLane((L) c.lane);
					freeLanes.add(Integer.valueOf(c.lane.position));
				}
			}

			currCommit.lane = nextFreeLane();
			currCommit.lane.parent = currCommit;
			activeLanes.add(currCommit.lane);

			int remaining = nChildren;
			for (int r = index - 1; r >= 0; r--) {
				final PlotCommit rObj = get(r);
				if (currCommit.isChild(rObj)) {
					if (--remaining == 0)
						break;
				}
				rObj.addPassingLane(currCommit.lane);
			}
		}
	}

