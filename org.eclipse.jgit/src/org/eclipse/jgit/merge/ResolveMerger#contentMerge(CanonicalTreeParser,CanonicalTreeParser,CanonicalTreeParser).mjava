	private boolean contentMerge(CanonicalTreeParser base,
			CanonicalTreeParser ours, CanonicalTreeParser theirs)
			throws FileNotFoundException, IllegalStateException, IOException {
		MergeFormatter fmt = new MergeFormatter();

		// do the merge
		MergeResult<RawText> result = MergeAlgorithm.merge(
				RawTextComparator.DEFAULT,
				getRawText(base.getEntryObjectId(), db),
				getRawText(ours.getEntryObjectId(), db),
				getRawText(theirs.getEntryObjectId(), db));

		File workTree = db.getWorkTree();
		if (workTree == null)
			// TODO: This should be handled by WorkingTreeIterators which
			// support write operations
			throw new UnsupportedOperationException();

		File of = new File(workTree, tw.getPathString());
		FileOutputStream fos = new FileOutputStream(of);
		try {
			fmt.formatMerge(fos, result, Arrays.asList(commitNames),
					Constants.CHARACTER_ENCODING);
		} finally {
			fos.close();
		}
		if (result.containsConflicts()) {
			// a conflict occured, the file will contain conflict markers
			// the index will be populated with the three stages and only the
			// workdir contains the halfways merged content
			add(tw.getRawPath(), base, DirCacheEntry.STAGE_1);
			add(tw.getRawPath(), ours, DirCacheEntry.STAGE_2);
			add(tw.getRawPath(), theirs, DirCacheEntry.STAGE_3);
			mergeResults.put(tw.getPathString(), result);
			return false;
		} else {
			// no conflict occured, the file will contain fully merged content.
			// the index will be populated with the new merged version
			DirCacheEntry dce = new DirCacheEntry(tw.getPathString());
			dce.setFileMode(tw.getFileMode(0));
			dce.setLastModified(of.lastModified());
			dce.setLength((int) of.length());
			InputStream is = new FileInputStream(of);
			try {
				dce.setObjectId(oi.insert(Constants.OBJ_BLOB, of.length(),
						is));
			} finally {
				is.close();
			}
			builder.add(dce);
			return true;
		}
	}

