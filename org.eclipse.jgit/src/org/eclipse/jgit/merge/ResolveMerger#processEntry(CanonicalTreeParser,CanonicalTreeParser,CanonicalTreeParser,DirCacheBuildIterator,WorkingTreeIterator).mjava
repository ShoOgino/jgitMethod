	/**
	 * Processes one path and tries to merge. This method will do all do all
	 * trivial (not content) merges and will also detect if a merge will fail.
	 * The merge will fail when one of the following is true
	 * <ul>
	 * <li>the index entry does not match the entry in ours. When merging one
	 * branch into the current HEAD, ours will point to HEAD and theirs will
	 * point to the other branch. It is assumed that the index matches the HEAD
	 * because it will only not match HEAD if it was populated before the merge
	 * operation. But the merge commit should not accidentally contain
	 * modifications done before the merge. Check the <a href=
	 * "http://www.kernel.org/pub/software/scm/git/docs/git-read-tree.html#_3_way_merge"
	 * >git read-tree</a> documentation for further explanations.</li>
	 * <li>A conflict was detected and the working-tree file is dirty. When a
	 * conflict is detected the content-merge algorithm will try to write a
	 * merged version into the working-tree. If the file is dirty we would
	 * override unsaved data.</li>
	 *
	 * @param base
	 *            the common base for ours and theirs
	 * @param ours
	 *            the ours side of the merge. When merging a branch into the
	 *            HEAD ours will point to HEAD
	 * @param theirs
	 *            the theirs side of the merge. When merging a branch into the
	 *            current HEAD theirs will point to the branch which is merged
	 *            into HEAD.
	 * @param index
	 *            the index entry
	 * @param work
	 *            the file in the working tree
	 * @return <code>false</code> if the merge will fail because the index entry
	 *         didn't match ours or the working-dir file was dirty and a
	 *         conflict occured
	 * @throws MissingObjectException
	 * @throws IncorrectObjectTypeException
	 * @throws CorruptObjectException
	 * @throws IOException
	 */
	private boolean processEntry(CanonicalTreeParser base,
			CanonicalTreeParser ours, CanonicalTreeParser theirs,
			DirCacheBuildIterator index, WorkingTreeIterator work)
			throws MissingObjectException, IncorrectObjectTypeException,
			CorruptObjectException, IOException {
		enterSubtree = true;
		final int modeO = tw.getRawMode(T_OURS);
		final int modeI = tw.getRawMode(T_INDEX);

		// Each index entry has to match ours, means: it has to be clean
		if (nonTree(modeI)
				&& !(tw.idEqual(T_INDEX, T_OURS) && modeO == modeI)) {
			failingPathes.put(tw.getPathString(), MergeFailureReason.DIRTY_INDEX);
			return false;
		}

		final int modeT = tw.getRawMode(T_THEIRS);
		if (nonTree(modeO) && modeO == modeT && tw.idEqual(T_OURS, T_THEIRS)) {
			// ours and theirs are equal: it doesn'nt matter
			// which one we choose. OURS is choosen here.
			add(tw.getRawPath(), ours, DirCacheEntry.STAGE_0);
			// no checkout needed!
			return true;
		}

		final int modeB = tw.getRawMode(T_BASE);
		if (nonTree(modeO) && modeB == modeT && tw.idEqual(T_BASE, T_THEIRS)) {
			// THEIRS was not changed compared to base. All changes must be in
			// OURS. Choose OURS.
			add(tw.getRawPath(), ours, DirCacheEntry.STAGE_0);
			return true;
		}

		if (modeB == modeO && tw.idEqual(T_BASE, T_OURS)) {
			// OURS was not changed compared to base. All changes must be in
			// THEIRS. Choose THEIRS.
			if (nonTree(modeT)) {
				DirCacheEntry e = add(tw.getRawPath(), theirs,
						DirCacheEntry.STAGE_0);
				if (e != null)
					toBeCheckedOut.put(tw.getPathString(), e);
				return true;
			} else if ((modeT == 0) && (modeB != 0)) {
				// we want THEIRS ... but THEIRS contains the deletion of the
				// file
				toBeCheckedOut.put(tw.getPathString(), null);
				return true;
			}
		}

		if (tw.isSubtree()) {
			// file/folder conflicts: here I want to detect only file/folder
			// conflict between ours and theirs. file/folder conflicts between
			// base/index/workingTree and something else are not relevant or
			// detected later
			if (nonTree(modeO) && !nonTree(modeT)) {
				if (nonTree(modeB))
					add(tw.getRawPath(), base, DirCacheEntry.STAGE_1);
				add(tw.getRawPath(), ours, DirCacheEntry.STAGE_2);
				unmergedPathes.add(tw.getPathString());
				enterSubtree = false;
				return true;
			}
			if (nonTree(modeT) && !nonTree(modeO)) {
				if (nonTree(modeB))
					add(tw.getRawPath(), base, DirCacheEntry.STAGE_1);
				add(tw.getRawPath(), theirs, DirCacheEntry.STAGE_3);
				unmergedPathes.add(tw.getPathString());
				enterSubtree = false;
				return true;
			}

			// ours and theirs are both folders or both files (and treewalk
			// tells us we are in a subtree because of index or working-dir).
			// If they are both folders no content-merge is required - we can
			// return here.
			if (!nonTree(modeO))
				return true;

			// ours and theirs are both files, just fall out of the if block
			// and do the content merge
		}

		if (nonTree(modeO) && nonTree(modeT)) {
			if (!inCore) {
				// We are going to update the worktree. Make sure the worktree
				// is not modified
				if (work != null
						&& (!nonTree(work.getEntryRawMode()) || work
								.isModified(index.getDirCacheEntry(), true,
										true))) {
					failingPathes.put(tw.getPathString(),
							MergeFailureReason.DIRTY_WORKTREE);
					return false;
				}
			}

			if (!contentMerge(base, ours, theirs)) {
				unmergedPathes.add(tw.getPathString());
			}
			modifiedFiles.add(tw.getPathString());
		}
		return true;
	}

