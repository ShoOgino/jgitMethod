	/**
	 * Index the region between <code>[ptr, end)</code> to find line starts.
	 * <p>
	 * The returned list is 1 indexed. Index 0 contains
	 * {@link java.lang.Integer#MIN_VALUE} to pad the list out.
	 * <p>
	 * Using a 1 indexed list means that line numbers can be directly accessed
	 * from the list, so <code>list.get(1)</code> (aka get line 1) returns
	 * <code>ptr</code>.
	 * <p>
	 * The last element (index <code>map.size()-1</code>) always contains
	 * <code>end</code>.
	 * <p>
	 * If the data contains a '\0' anywhere, the whole region is considered
	 * binary and a LineMap corresponding to a single line is returned.
	 * </p>
	 *
	 * @param buf
	 *            buffer to scan.
	 * @param ptr
	 *            position within the buffer corresponding to the first byte of
	 *            line 1.
	 * @param end
	 *            1 past the end of the content within <code>buf</code>.
	 * @return a line map indexing the start position of each line.
	 */
	public static final IntList lineMap(final byte[] buf, int ptr, int end) {
		int start = ptr;

		// Experimentally derived from multiple source repositories
		// the average number of bytes/line is 36. Its a rough guess
		// to initially size our map close to the target.
		IntList map = new IntList((end - ptr) / 36);
		map.add(Integer.MIN_VALUE);
		boolean foundLF = true;
		for (; ptr < end; ptr++) {
			if (foundLF) {
				map.add(ptr);
			}

			if (buf[ptr] == '\0') {
				// binary data.
				map = new IntList(3);
				map.add(Integer.MIN_VALUE);
				map.add(start);
				break;
			}

			foundLF = (buf[ptr] == '\n');
		}
		map.add(end);
		return map;
	}

