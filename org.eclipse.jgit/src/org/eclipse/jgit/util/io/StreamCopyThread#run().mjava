	@Override
	public void run() {
		try {
			final byte[] buf = new byte[BUFFER_SIZE];
			int flushCountBeforeRead = 0;
			boolean readInterrupted = false;
			for (;;) {
				try {
					if (readInterrupted) {
						dst.flush();
						readInterrupted = false;
						if (!flushCount.compareAndSet(flushCountBeforeRead, 0)) {
							// There was a flush() call since last blocked read.
							// Set interrupt status, so next blocked read will throw
							// an InterruptedIOException and we will flush again.
							interrupt();
						}
					}

					if (done)
						break;

					flushCountBeforeRead = flushCount.get();
					final int n;
					try {
						n = src.read(buf);
					} catch (InterruptedIOException wakey) {
						readInterrupted = true;
						continue;
					}
					if (n < 0)
						break;

					boolean writeInterrupted = false;
					for (;;) {
						try {
							dst.write(buf, 0, n);
						} catch (InterruptedIOException wakey) {
							writeInterrupted = true;
							continue;
						}

						// set interrupt status, which will be checked
						// when we block in src.read
						if (writeInterrupted || flushCount.get() > 0)
							interrupt();
						break;
					}
				} catch (IOException e) {
					break;
				}
			}
		} finally {
			try {
				src.close();
			} catch (IOException e) {
				// Ignore IO errors on close
			}
			try {
				dst.close();
			} catch (IOException e) {
				// Ignore IO errors on close
			}
		}
	}

