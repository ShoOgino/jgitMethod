	/**
	 * Runs a garbage collector on a {@link FileRepository}. It will
	 * <ul>
	 * <li>pack loose references into packed-refs</li>
	 * <li>repack all reachable objects into new pack files and delete the old
	 * pack files</li>
	 * <li>prune all loose objects which are now reachable by packs</li>
	 * </ul>
	 *
	 * If {@link #setAuto(boolean)} was set to {@code true} {@code gc} will
	 * first check whether any housekeeping is required; if not, it exits
	 * without performing any work.
	 *
	 * If {@link #setBackground(boolean)} was set to {@code true}
	 * {@code collectGarbage} will start the gc in the background, and then
	 * return immediately. In this case, errors will not be reported except in
	 * gc.log.
	 *
	 * @return the collection of {@link PackFile}'s which are newly created
	 * @throws IOException
	 * @throws ParseException
	 *             If the configuration parameter "gc.pruneexpire" couldn't be
	 *             parsed
	 */
	// TODO(ms): in 5.0 change signature and return Future<Collection<PackFile>>
	public Collection<PackFile> gc() throws IOException, ParseException {
		final GcLog gcLog = background ? new GcLog(repo) : null;
		if (gcLog != null && !gcLog.lock(background)) {
			// there is already a background gc running
			return Collections.emptyList();
		}

		Callable<Collection<PackFile>> gcTask = () -> {
			try {
				Collection<PackFile> newPacks = doGc();
				if (automatic && tooManyLooseObjects() && gcLog != null) {
					String message = JGitText.get().gcTooManyUnpruned;
					gcLog.write(message);
					gcLog.commit();
				}
				return newPacks;
			} catch (IOException | ParseException e) {
				if (background) {
					if (gcLog == null) {
						// Lacking a log, there's no way to report this.
						return Collections.emptyList();
					}
					try {
						gcLog.write(e.getMessage());
						StringWriter sw = new StringWriter();
						e.printStackTrace(new PrintWriter(sw));
						gcLog.write(sw.toString());
						gcLog.commit();
					} catch (IOException e2) {
						e2.addSuppressed(e);
						LOG.error(e2.getMessage(), e2);
					}
				} else {
					throw new JGitInternalException(e.getMessage(), e);
				}
			} finally {
				if (gcLog != null) {
					gcLog.unlock();
				}
			}
			return Collections.emptyList();
		};
		Future<Collection<PackFile>> result = executor.submit(gcTask);
		if (background) {
			// TODO(ms): in 5.0 change signature and return the Future
			return Collections.emptyList();
		}
		try {
			return result.get();
		} catch (InterruptedException | ExecutionException e) {
			throw new IOException(e);
		}
	}

