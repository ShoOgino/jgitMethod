	Collection<BitmapCommit> doCommitSelection(int commitRange)
			throws MissingObjectException, IncorrectObjectTypeException,
			IOException {
		pm.beginTask(JGitText.get().selectingCommits, ProgressMonitor.UNKNOWN);
		RevWalk rw = new RevWalk(reader);
		rw.setRetainBody(false);
		WalkResult result = findPaths(rw, commitRange);
		pm.endTask();

		int totCommits = result.commitsByOldest.length - result.commitStartPos;
		BlockList<BitmapCommit> selections = new BlockList<BitmapCommit>(
				totCommits / minCommits + 1);
		for (BitmapCommit reuse : result.reuse)
			selections.add(reuse);

		if (totCommits == 0) {
			for (AnyObjectId id : result.peeledWant)
				selections.add(new BitmapCommit(id, false, 0));
			return selections;
		}

		pm.beginTask(JGitText.get().selectingCommits, totCommits);

		for (BitmapBuilder bitmapableCommits : result.paths) {
			int cardinality = bitmapableCommits.cardinality();

			List<List<BitmapCommit>> running = new ArrayList<
					List<BitmapCommit>>();

			// Insert bitmaps at the offsets suggested by the
			// nextSelectionDistance() heuristic.
			int index = -1;
			int nextIn = nextSelectionDistance(0, cardinality);
			int nextFlg = nextIn == maxCommits ? PackBitmapIndex.FLAG_REUSE : 0;
			boolean mustPick = nextIn == 0;
			for (RevCommit c : result) {
				if (!bitmapableCommits.contains(c))
					continue;

				index++;
				nextIn--;
				pm.update(1);

				// Always pick the items in want and prefer merge commits.
				if (result.peeledWant.remove(c)) {
					if (nextIn > 0)
						nextFlg = 0;
				} else if (!mustPick && ((nextIn > 0)
						|| (c.getParentCount() <= 1 && nextIn > -minCommits))) {
					continue;
				}

				int flags = nextFlg;
				nextIn = nextSelectionDistance(index, cardinality);
				nextFlg = nextIn == maxCommits ? PackBitmapIndex.FLAG_REUSE : 0;
				mustPick = nextIn == 0;

				BitmapBuilder fullBitmap = commitBitmapIndex.newBitmapBuilder();
				rw.reset();
				rw.markStart(c);
				for (AnyObjectId objectId : result.reuse)
					rw.markUninteresting(rw.parseCommit(objectId));
				rw.setRevFilter(
						PackWriterBitmapWalker.newRevFilter(null, fullBitmap));

				while (rw.next() != null) {
					// Work is done in the RevFilter.
				}

				List<List<BitmapCommit>> matches = new ArrayList<
						List<BitmapCommit>>();
				for (List<BitmapCommit> list : running) {
					BitmapCommit last = list.get(list.size() - 1);
					if (fullBitmap.contains(last))
						matches.add(list);
				}

				List<BitmapCommit> match;
				if (matches.isEmpty()) {
					match = new ArrayList<BitmapCommit>();
					running.add(match);
				} else {
					match = matches.get(0);
					// Append to longest
					for (List<BitmapCommit> list : matches) {
						if (list.size() > match.size())
							match = list;
					}
				}
				match.add(new BitmapCommit(c, !match.isEmpty(), flags));
				writeBitmaps.addBitmap(c, fullBitmap, 0);
			}

			for (List<BitmapCommit> list : running)
				selections.addAll(list);
		}
		writeBitmaps.clearBitmaps(); // Remove the temporary commit bitmaps.

		// Add the remaining peeledWant
		for (AnyObjectId remainingWant : result.peeledWant)
			selections.add(new BitmapCommit(remainingWant, false, 0));

		pm.endTask();
		return selections;
	}

