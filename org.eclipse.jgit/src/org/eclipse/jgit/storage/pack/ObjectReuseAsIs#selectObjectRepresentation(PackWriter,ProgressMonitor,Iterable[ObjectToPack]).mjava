	/**
	 * Select the best object representation for a packer.
	 * <p>
	 * Implementations should iterate through all available representations of
	 * an object, and pass them in turn to the PackWriter though
	 * {@link PackWriter#select(ObjectToPack, StoredObjectRepresentation)} so
	 * the writer can select the most suitable representation to reuse into the
	 * output stream.
	 * <p>
	 * If the implementation returns CachedPack from {@link #getCachedPacks()},
	 * it must consider the representation of any object that is stored in any
	 * of the offered CachedPacks. PackWriter relies on this behavior to prune
	 * duplicate objects out of the pack stream when it selects a CachedPack and
	 * the object was also reached through the thin-pack enumeration.
	 * <p>
	 * The implementation may choose to consider multiple objects at once on
	 * concurrent threads, but must evaluate all representations of an object
	 * within the same thread.
	 *
	 * @param packer
	 *            the packer that will write the object in the near future.
	 * @param monitor
	 *            progress monitor, implementation should update the monitor
	 *            once for each item in the iteration when selection is done.
	 * @param objects
	 *            the objects that are being packed.
	 * @throws MissingObjectException
	 *             there is no representation available for the object, as it is
	 *             no longer in the repository. Packing will abort.
	 * @throws IOException
	 *             the repository cannot be accessed. Packing will abort.
	 */
	public void selectObjectRepresentation(PackWriter packer,
			ProgressMonitor monitor, Iterable<ObjectToPack> objects)
			throws IOException, MissingObjectException;

