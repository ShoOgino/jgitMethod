	/**
	 * Commits the object header onto the stream.
	 * <p>
	 * Once the header has been written, the object representation must be fully
	 * output, or packing must abort abnormally.
	 *
	 * @param otp
	 *            the object to pack. Header information is obtained.
	 * @param rawLength
	 *            number of bytes of the inflated content. For an object that is
	 *            in whole object format, this is the same as the object size.
	 *            For an object that is in a delta format, this is the size of
	 *            the inflated delta instruction stream.
	 * @throws IOException
	 *             the underlying stream refused to accept the header.
	 */
	public void writeHeader(ObjectToPack otp, long rawLength)
			throws IOException {
		if (otp.isDeltaRepresentation()) {
			if (packWriter.isDeltaBaseAsOffset()) {
				ObjectToPack baseInPack = otp.getDeltaBase();
				if (baseInPack != null && baseInPack.isWritten()) {
					final long start = count;
					int n = encodeTypeSize(Constants.OBJ_OFS_DELTA, rawLength);
					write(headerBuffer, 0, n);

					long offsetDiff = start - baseInPack.getOffset();
					n = headerBuffer.length - 1;
					headerBuffer[n] = (byte) (offsetDiff & 0x7F);
					while ((offsetDiff >>= 7) > 0)
						headerBuffer[--n] = (byte) (0x80 | (--offsetDiff & 0x7F));
					write(headerBuffer, n, headerBuffer.length - n);
					return;
				}
			}

			int n = encodeTypeSize(Constants.OBJ_REF_DELTA, rawLength);
			otp.getDeltaBaseId().copyRawTo(headerBuffer, n);
			write(headerBuffer, 0, n + Constants.OBJECT_ID_LENGTH);
		} else {
			int n = encodeTypeSize(otp.getType(), rawLength);
			write(headerBuffer, 0, n);
		}
	}

