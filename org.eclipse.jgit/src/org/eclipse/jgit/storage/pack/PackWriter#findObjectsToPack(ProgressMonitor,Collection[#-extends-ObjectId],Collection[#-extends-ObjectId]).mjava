	private void findObjectsToPack(final ProgressMonitor countingMonitor,
			final Collection<? extends ObjectId> want,
			Collection<? extends ObjectId> have)
			throws MissingObjectException, IOException,
			IncorrectObjectTypeException {
		countingMonitor.beginTask(JGitText.get().countingObjects,
				ProgressMonitor.UNKNOWN);

		if (have == null)
			have = Collections.emptySet();

		List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());
		all.addAll(want);
		all.addAll(have);

		final ObjectWalk walker = new ObjectWalk(reader);
		walker.setRetainBody(false);
		if (have.isEmpty())
			walker.sort(RevSort.COMMIT_TIME_DESC);
		else {
			walker.sort(RevSort.TOPO);
			if (thin)
				walker.sort(RevSort.BOUNDARY, true);
		}

		AsyncRevObjectQueue q = walker.parseAny(all, true);
		try {
			for (;;) {
				try {
					RevObject o = q.next();
					if (o == null)
						break;
					if (have.contains(o))
						walker.markUninteresting(o);
					else
						walker.markStart(o);
				} catch (MissingObjectException e) {
					if (ignoreMissingUninteresting
							&& have.contains(e.getObjectId()))
						continue;
					throw e;
				}
			}
		} finally {
			q.release();
		}

		final int maxBases = config.getDeltaSearchWindowSize();
		Set<RevTree> baseTrees = new HashSet<RevTree>();
		RevObject o;
		while ((o = walker.next()) != null) {
			if (o.has(RevFlag.UNINTERESTING)) {
				if (baseTrees.size() <= maxBases)
					baseTrees.add(((RevCommit) o).getTree());
				continue;
			}
			addObject(o, 0);
			countingMonitor.update(1);
		}

		BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //
				edgeObjects, reader);
		while ((o = walker.nextObject()) != null) {
			if (o.has(RevFlag.UNINTERESTING))
				continue;

			int pathHash = walker.getPathHashCode();
			byte[] pathBuf = walker.getPathBuffer();
			int pathLen = walker.getPathLength();

			bases.addBase(o.getType(), pathBuf, pathLen, pathHash);
			addObject(o, pathHash);
			countingMonitor.update(1);
		}
		countingMonitor.endTask();
	}

