	private void findObjectsToPack(final ProgressMonitor countingMonitor,
			final Collection<? extends ObjectId> interestingObjects,
			final Collection<? extends ObjectId> uninterestingObjects)
			throws MissingObjectException, IOException,
			IncorrectObjectTypeException {
		countingMonitor.beginTask(JGitText.get().countingObjects,
				ProgressMonitor.UNKNOWN);

		List<ObjectId> all = new ArrayList<ObjectId>(interestingObjects.size());
		for (ObjectId id : interestingObjects)
			all.add(id.copy());

		final Set<ObjectId> not;
		if (uninterestingObjects != null && !uninterestingObjects.isEmpty()) {
			not = new HashSet<ObjectId>();
			for (ObjectId id : uninterestingObjects)
				not.add(id.copy());
			all.addAll(not);
		} else
			not = Collections.emptySet();

		final ObjectWalk walker = new ObjectWalk(reader);
		final RevFlag hasObjectList = walker.newFlag("hasObjectList");

		walker.setRetainBody(false);
		if (not.isEmpty()) {
			walker.sort(RevSort.COMMIT_TIME_DESC);
			for (ObjectId listName : reader.getAvailableObjectLists())
				walker.lookupCommit(listName).add(hasObjectList);
		} else {
			walker.sort(RevSort.TOPO);
			if (thin)
				walker.sort(RevSort.BOUNDARY, true);
		}

		AsyncRevObjectQueue q = walker.parseAny(all, true);
		try {
			for (;;) {
				try {
					RevObject o = q.next();
					if (o == null)
						break;
					if (not.contains(o.copy()))
						walker.markUninteresting(o);
					else
						walker.markStart(o);
				} catch (MissingObjectException e) {
					if (ignoreMissingUninteresting
							&& not.contains(e.getObjectId()))
						continue;
					throw e;
				}
			}
		} finally {
			q.release();
		}

		RevObject listName = null;
		RevObject o;

		while ((o = walker.next()) != null) {
			if (o.has(hasObjectList)) {
				listName = o;
				break;
			}
			addResultOrBase(o, 0);
			countingMonitor.update(1);
		}
		if (listName != null) {
			addByObjectList(listName, countingMonitor, walker,
					interestingObjects);
		} else {
			while ((o = walker.nextObject()) != null) {
				addResultOrBase(o, walker.getPathHashCode());
				countingMonitor.update(1);
			}
		}
		countingMonitor.endTask();
	}

