	private void findObjectsToPack(final ProgressMonitor countingMonitor,
			final ObjectWalk walker, final Collection<? extends ObjectId> want,
			Collection<? extends ObjectId> have)
			throws MissingObjectException, IOException,
			IncorrectObjectTypeException {
		final long countingStart = System.currentTimeMillis();
		countingMonitor.beginTask(JGitText.get().countingObjects,
				ProgressMonitor.UNKNOWN);

		if (have == null)
			have = Collections.emptySet();

		stats.interestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(want));
		stats.uninterestingObjects = Collections.unmodifiableSet(new HashSet<ObjectId>(have));

		List<ObjectId> all = new ArrayList<ObjectId>(want.size() + have.size());
		all.addAll(want);
		all.addAll(have);

		final Map<ObjectId, CachedPack> tipToPack = new HashMap<ObjectId, CachedPack>();
		final RevFlag inCachedPack = walker.newFlag("inCachedPack");
		final RevFlag include = walker.newFlag("include");
		final RevFlag added = walker.newFlag("added");

		final RevFlagSet keepOnRestart = new RevFlagSet();
		keepOnRestart.add(inCachedPack);

		walker.setRetainBody(false);
		walker.carry(include);

		int haveEst = have.size();
		if (have.isEmpty()) {
			walker.sort(RevSort.COMMIT_TIME_DESC);
			if (useCachedPacks && reuseSupport != null) {
				for (CachedPack pack : reuseSupport.getCachedPacks()) {
					for (ObjectId id : pack.getTips()) {
						tipToPack.put(id, pack);
						all.add(id);
					}
				}
				haveEst += tipToPack.size();
			}
		} else {
			walker.sort(RevSort.TOPO);
			if (thin)
				walker.sort(RevSort.BOUNDARY, true);
		}

		List<RevObject> wantObjs = new ArrayList<RevObject>(want.size());
		List<RevObject> haveObjs = new ArrayList<RevObject>(haveEst);

		AsyncRevObjectQueue q = walker.parseAny(all, true);
		try {
			for (;;) {
				try {
					RevObject o = q.next();
					if (o == null)
						break;

					if (tipToPack.containsKey(o))
						o.add(inCachedPack);

					if (have.contains(o)) {
						haveObjs.add(o);
						walker.markUninteresting(o);
					} else if (want.contains(o)) {
						o.add(include);
						wantObjs.add(o);
						walker.markStart(o);
					}
				} catch (MissingObjectException e) {
					if (ignoreMissingUninteresting
							&& have.contains(e.getObjectId()))
						continue;
					throw e;
				}
			}
		} finally {
			q.release();
		}

		int typesToPrune = 0;
		final int maxBases = config.getDeltaSearchWindowSize();
		Set<RevTree> baseTrees = new HashSet<RevTree>();
		List<RevCommit> commits = new ArrayList<RevCommit>();
		RevCommit c;
		while ((c = walker.next()) != null) {
			if (c.has(inCachedPack)) {
				CachedPack pack = tipToPack.get(c);
				if (includesAllTips(pack, include, walker)) {
					useCachedPack(walker, keepOnRestart, //
							wantObjs, haveObjs, pack);
					commits = new ArrayList<RevCommit>();

					countingMonitor.endTask();
					countingMonitor.beginTask(JGitText.get().countingObjects,
							ProgressMonitor.UNKNOWN);
					continue;
				}
			}

			if (c.has(RevFlag.UNINTERESTING)) {
				if (baseTrees.size() <= maxBases)
					baseTrees.add(c.getTree());
				continue;
			}

			commits.add(c);
			countingMonitor.update(1);
		}

		if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {
			ArrayList<ObjectToPack> list = (ArrayList<ObjectToPack>) objectsLists[Constants.OBJ_COMMIT];
			list.ensureCapacity(list.size() + commits.size());
		}
		for (RevCommit cmit : commits) {
			if (!cmit.has(added)) {
				cmit.add(added);
				addObject(cmit, 0);
			}

			for (int i = 0; i < cmit.getParentCount(); i++) {
				RevCommit p = cmit.getParent(i);
				if (!p.has(added) && !p.has(RevFlag.UNINTERESTING)) {
					p.add(added);
					addObject(p, 0);
				}
			}
		}
		commits = null;

		for (CachedPack p : cachedPacks) {
			for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {
				if (baseTrees.size() <= maxBases)
					baseTrees.add(walker.lookupCommit(d).getTree());
				objectsMap.get(d).setEdge();
				typesToPrune |= 1 << Constants.OBJ_COMMIT;
			}
		}

		BaseSearch bases = new BaseSearch(countingMonitor, baseTrees, //
				objectsMap, edgeObjects, reader);
		RevObject o;
		while ((o = walker.nextObject()) != null) {
			if (o.has(RevFlag.UNINTERESTING))
				continue;

			int pathHash = walker.getPathHashCode();
			byte[] pathBuf = walker.getPathBuffer();
			int pathLen = walker.getPathLength();

			bases.addBase(o.getType(), pathBuf, pathLen, pathHash);
			addObject(o, pathHash);
			countingMonitor.update(1);
		}

		for (CachedPack p : cachedPacks) {
			for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {
				objectsMap.get(d).setEdge();
				typesToPrune |= 1 << Constants.OBJ_TREE;
			}
			for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {
				objectsMap.get(d).setEdge();
				typesToPrune |= 1 << Constants.OBJ_BLOB;
			}
			for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {
				objectsMap.get(d).setEdge();
				typesToPrune |= 1 << Constants.OBJ_TAG;
			}
		}

		if (typesToPrune != 0) {
			pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);
			pruneObjectList(typesToPrune, Constants.OBJ_TREE);
			pruneObjectList(typesToPrune, Constants.OBJ_BLOB);
			pruneObjectList(typesToPrune, Constants.OBJ_TAG);
		}

		for (CachedPack pack : cachedPacks)
			countingMonitor.update((int) pack.getObjectCount());
		countingMonitor.endTask();
		stats.timeCounting = System.currentTimeMillis() - countingStart;
	}

