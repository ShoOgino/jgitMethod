	private WalkResult findPaths(RevWalk rw, int expectedNumCommits)
			throws MissingObjectException, IOException {
		BitmapBuilder reuseBitmap = commitBitmapIndex.newBitmapBuilder();
		List<BitmapCommit> reuse = new ArrayList<BitmapCommit>();
		for (PackBitmapIndexRemapper.Entry entry : bitmapRemapper) {
			if ((entry.getFlags() & FLAG_REUSE) != FLAG_REUSE)
				continue;

			RevObject ro = rw.peel(rw.parseAny(entry));
			if (ro instanceof RevCommit) {
				RevCommit rc = (RevCommit) ro;
				reuse.add(new BitmapCommit(rc, false, entry.getFlags()));
				rw.markUninteresting(rc);

				EWAHCompressedBitmap bitmap = bitmapRemapper.ofObjectType(
						bitmapRemapper.getBitmap(rc), Constants.OBJ_COMMIT);
				writeBitmaps.addBitmap(rc, bitmap, 0);
				reuseBitmap.add(rc, Constants.OBJ_COMMIT);
			}
		}
		writeBitmaps.clearBitmaps(); // Remove temporary bitmaps

		// Do a RevWalk by commit time descending. Keep track of all the paths
		// from the wants.
		List<BitmapBuilder> paths = new ArrayList<BitmapBuilder>(want.size());
		Set<RevCommit> peeledWant = new HashSet<RevCommit>(want.size());
		for (AnyObjectId objectId : want) {
			RevObject ro = rw.peel(rw.parseAny(objectId));
			if (ro instanceof RevCommit && !reuseBitmap.contains(ro)) {
				RevCommit rc = (RevCommit) ro;
				peeledWant.add(rc);
				rw.markStart(rc);

				BitmapBuilder bitmap = commitBitmapIndex.newBitmapBuilder();
				bitmap.or(reuseBitmap);
				bitmap.add(rc, Constants.OBJ_COMMIT);
				paths.add(bitmap);
			}
		}

		// Update the paths from the wants and create a list of commits in
		// reverse iteration order.
		RevCommit[] commits = new RevCommit[expectedNumCommits];
		int pos = commits.length;
		RevCommit rc;
		while ((rc = rw.next()) != null) {
			commits[--pos] = rc;
			for (BitmapBuilder path : paths) {
				if (path.contains(rc)) {
					for (RevCommit c : rc.getParents())
						path.add(c, Constants.OBJ_COMMIT);
				}
			}

			pm.update(1);
		}

		// Remove the reused bitmaps from the paths
		if (!reuse.isEmpty())
			for (BitmapBuilder bitmap : paths)
				bitmap.andNot(reuseBitmap);

		// Sort the paths
		List<BitmapBuilder> distinctPaths = new ArrayList<BitmapBuilder>(paths.size());
		while (!paths.isEmpty()) {
			Collections.sort(paths, BUILDER_BY_CARDINALITY_DSC);
			BitmapBuilder largest = paths.remove(0);
			distinctPaths.add(largest);

			// Update the remaining paths, by removing the objects from
			// the path that was just added.
			for (int i = paths.size() - 1; i >= 0; i--)
				paths.get(i).andNot(largest);
		}

		return new WalkResult(peeledWant, commits, pos, distinctPaths, reuse);
	}

