	ObjectLoader load(final WindowCursor curs, final long pos)
			throws IOException {
		final byte[] ib = curs.tempId;
		readFully(pos, ib, 0, 20, curs);
		int c = ib[0] & 0xff;
		final int type = (c >> 4) & 7;
		long sz = c & 15;
		int shift = 4;
		int p = 1;
		while ((c & 0x80) != 0) {
			c = ib[p++] & 0xff;
			sz += (c & 0x7f) << shift;
			shift += 7;
		}

		try {
			switch (type) {
			case Constants.OBJ_COMMIT:
			case Constants.OBJ_TREE:
			case Constants.OBJ_BLOB:
			case Constants.OBJ_TAG: {
				if (sz < curs.getStreamFileThreshold()) {
					byte[] data = decompress(pos + p, sz, curs);
					return new ObjectLoader.SmallObject(type, data);
				}
				return new LargePackedWholeObject(type, sz, pos, p, this, curs.db);
			}

			case Constants.OBJ_OFS_DELTA: {
				c = ib[p++] & 0xff;
				long ofs = c & 127;
				while ((c & 128) != 0) {
					ofs += 1;
					c = ib[p++] & 0xff;
					ofs <<= 7;
					ofs += (c & 127);
				}
				return loadDelta(pos, p, sz, pos - ofs, curs);
			}

			case Constants.OBJ_REF_DELTA: {
				readFully(pos + p, ib, 0, 20, curs);
				long ofs = findDeltaBase(ObjectId.fromRaw(ib));
				return loadDelta(pos, p + 20, sz, ofs, curs);
			}

			default:
				throw new IOException(MessageFormat.format(
						JGitText.get().unknownObjectType, type));
			}
		} catch (DataFormatException dfe) {
			CorruptObjectException coe = new CorruptObjectException(
					MessageFormat.format(
							JGitText.get().objectAtHasBadZlibStream, pos,
							getPackFile()));
			coe.initCause(dfe);
			throw coe;
		}
	}

