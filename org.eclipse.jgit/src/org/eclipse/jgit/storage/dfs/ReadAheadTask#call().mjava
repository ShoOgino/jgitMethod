	public Void call() {
		int idx = 0;
		try {
			synchronized (this) {
				if (channel.isOpen())
					running = true;
				else
					return null;
			}

			long position = channel.position();
			for (; idx < futures.size() && !Thread.interrupted(); idx++) {
				BlockFuture f = futures.get(idx);
				if (cache.contains(f.pack, f.start)) {
					f.done();
					continue;
				}

				if (position != f.start)
					channel.position(f.start);

				int size = (int) (f.end - f.start);
				byte[] buf = new byte[size];
				if (IO.read(channel, buf, 0, size) != size)
					throw new EOFException();

				cache.put(new DfsBlock(f.pack, f.start, buf));
				f.done();
				position = f.end;
			}
		} catch (IOException err) {
			// Ignore read-ahead errors. These will be caught later on.
		} finally {
			for (; idx < futures.size(); idx++)
				futures.get(idx).abort();
			close();
		}
		return null;
	}

