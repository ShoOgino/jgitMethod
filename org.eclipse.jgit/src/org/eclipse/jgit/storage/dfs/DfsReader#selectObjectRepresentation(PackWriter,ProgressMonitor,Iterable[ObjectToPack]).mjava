	public void selectObjectRepresentation(PackWriter packer,
			ProgressMonitor monitor, Iterable<ObjectToPack> objects)
			throws IOException, MissingObjectException {
		DfsPackFile[] packList = db.getPacks();
		if (packList.length == 0) {
			Iterator<ObjectToPack> itr = objects.iterator();
			if (itr.hasNext())
				throw new MissingObjectException(itr.next(), "unknown");
			return;
		}

		int packIndex = 0;
		DfsPackFile packLast = packList[packIndex];

		int updated = 0;
		int posted = 0;
		List<DfsObjectRepresentation> all = new BlockList<DfsObjectRepresentation>();
		for (ObjectToPack otp : objects) {
			long p = packLast.findOffset(this, otp);
			if (p < 0) {
				int skip = packIndex;
				for (packIndex = 0; packIndex < packList.length; packIndex++) {
					if (skip == packIndex)
						continue;
					packLast = packList[packIndex];
					p = packLast.findOffset(this, otp);
					if (0 < p)
						break;
				}
				if (packIndex == packList.length)
					throw new MissingObjectException(otp, otp.getType());
			}

			DfsObjectRepresentation r = new DfsObjectRepresentation(otp);
			r.pack = packLast;
			r.packIndex = packIndex;
			r.offset = p;
			all.add(r);

			if ((++updated & 1) == 1) {
				monitor.update(1); // Update by 50%, the other 50% is below.
				posted++;
			}
		}
		Collections.sort(all, REPRESENTATION_SORT);

		try {
			wantReadAhead = true;
			for (DfsObjectRepresentation r : all) {
				r.pack.representation(this, r);
				packer.select(r.object, r);
				if ((++updated & 1) == 1) {
					monitor.update(1);
					posted++;
				}
			}
		} finally {
			cancelReadAhead();
		}
		if (posted < all.size())
			monitor.update(all.size() - posted);
	}

