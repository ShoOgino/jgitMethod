	/**
	 * Construct and write tree out of index.
	 *
	 * @return SHA-1 of the constructed tree
	 *
	 * @throws IOException
	 */
	public ObjectId writeTree() throws IOException {
		checkWriteOk();
		ObjectInserter inserter = db.newObjectInserter();
			try {
			Tree current = new Tree(db);
			Stack<Tree> trees = new Stack<Tree>();
			trees.push(current);
			String[] prevName = new String[0];
			for (Entry e : entries.values()) {
				if (e.getStage() != 0)
					continue;
				String[] newName = splitDirPath(e.getName());
				int c = longestCommonPath(prevName, newName);
				while (c < trees.size() - 1) {
					current.setId(inserter.insert(Constants.OBJ_TREE, current.format()));
					trees.pop();
					current = trees.isEmpty() ? null : (Tree) trees.peek();
				}
				while (trees.size() < newName.length) {
					if (!current.existsTree(newName[trees.size() - 1])) {
						current = new Tree(current, Constants.encode(newName[trees.size() - 1]));
						current.getParent().addEntry(current);
						trees.push(current);
					} else {
						current = (Tree) current.findTreeMember(newName[trees
								.size() - 1]);
						trees.push(current);
					}
				}
				FileTreeEntry ne = new FileTreeEntry(current, e.sha1,
						Constants.encode(newName[newName.length - 1]),
						(e.mode & FileMode.EXECUTABLE_FILE.getBits()) == FileMode.EXECUTABLE_FILE.getBits());
				current.addEntry(ne);
			}
			while (!trees.isEmpty()) {
				current.setId(inserter.insert(Constants.OBJ_TREE, current.format()));
				trees.pop();
				if (!trees.isEmpty())
					current = trees.peek();
			}
			inserter.flush();
			return current.getId();
		} finally {
			inserter.release();
		}
	}

