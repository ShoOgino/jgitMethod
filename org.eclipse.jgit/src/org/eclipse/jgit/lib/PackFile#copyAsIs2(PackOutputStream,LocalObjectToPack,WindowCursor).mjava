	private void copyAsIs2(PackOutputStream out, LocalObjectToPack src,
			WindowCursor curs) throws IOException,
			StoredObjectRepresentationNotAvailableException {
		final CRC32 crc1 = new CRC32();
		final CRC32 crc2 = new CRC32();
		final byte[] buf = out.getCopyBuffer();

		// Rip apart the header so we can discover the size.
		//
		readFully(src.copyOffset, buf, 0, 20, curs);
		int c = buf[0] & 0xff;
		final int typeCode = (c >> 4) & 7;
		long inflatedLength = c & 15;
		int shift = 4;
		int headerCnt = 1;
		while ((c & 0x80) != 0) {
			c = buf[headerCnt++] & 0xff;
			inflatedLength += (c & 0x7f) << shift;
			shift += 7;
		}

		if (typeCode == Constants.OBJ_OFS_DELTA) {
			do {
				c = buf[headerCnt++] & 0xff;
			} while ((c & 128) != 0);
			crc1.update(buf, 0, headerCnt);
			crc2.update(buf, 0, headerCnt);
		} else if (typeCode == Constants.OBJ_REF_DELTA) {
			crc1.update(buf, 0, headerCnt);
			crc2.update(buf, 0, headerCnt);

			readFully(src.copyOffset + headerCnt, buf, 0, 20, curs);
			crc1.update(buf, 0, 20);
			crc2.update(buf, 0, headerCnt);
			headerCnt += 20;
		} else {
			crc1.update(buf, 0, headerCnt);
			crc2.update(buf, 0, headerCnt);
		}

		final long dataOffset = src.copyOffset + headerCnt;
		final long dataLength;
		final long expectedCRC;

		// Verify the object isn't corrupt before sending. If it is,
		// we report it missing instead.
		//
		try {
			dataLength = findEndOffset(src.copyOffset) - dataOffset;

			if (idx().hasCRC32Support()) {
				// Index has the CRC32 code cached, validate the object.
				//
				expectedCRC = idx().findCRC32(src);

				long pos = dataOffset;
				long cnt = dataLength;
				while (cnt > 0) {
					final int n = (int) Math.min(cnt, buf.length);
					readFully(pos, buf, 0, n, curs);
					crc1.update(buf, 0, n);
					pos += n;
					cnt -= n;
				}
				if (crc1.getValue() != expectedCRC) {
					setCorrupt(src.copyOffset);
					throw new CorruptObjectException(MessageFormat.format(
							JGitText.get().objectAtHasBadZlibStream,
							src.copyOffset, getPackFile()));
				}
			} else {
				// We don't have a CRC32 code in the index, so compute it
				// now while inflating the raw data to get zlib to tell us
				// whether or not the data is safe.
				//
				long pos = dataOffset;
				long cnt = dataLength;
				Inflater inf = curs.inflater();
				byte[] tmp = new byte[1024];
				while (cnt > 0) {
					final int n = (int) Math.min(cnt, buf.length);
					readFully(pos, buf, 0, n, curs);
					crc1.update(buf, 0, n);
					inf.setInput(buf, 0, n);
					while (inf.inflate(tmp, 0, tmp.length) > 0)
						continue;
					pos += n;
					cnt -= n;
				}
				if (!inf.finished()) {
					setCorrupt(src.copyOffset);
					throw new EOFException(MessageFormat.format(
							JGitText.get().shortCompressedStreamAt,
							src.copyOffset));
				}
				expectedCRC = crc1.getValue();
			}
		} catch (DataFormatException dataFormat) {
			setCorrupt(src.copyOffset);

			CorruptObjectException corruptObject = new CorruptObjectException(
					MessageFormat.format(
							JGitText.get().objectAtHasBadZlibStream,
							src.copyOffset, getPackFile()));
			corruptObject.initCause(dataFormat);

			StoredObjectRepresentationNotAvailableException gone;
			gone = new StoredObjectRepresentationNotAvailableException(src);
			gone.initCause(corruptObject);
			throw gone;

		} catch (IOException ioError) {
			StoredObjectRepresentationNotAvailableException gone;
			gone = new StoredObjectRepresentationNotAvailableException(src);
			gone.initCause(ioError);
			throw gone;
		}

		if (dataLength <= buf.length) {
			// Tiny optimization: Lots of objects are very small deltas or
			// deflated commits that are likely to fit in the copy buffer.
			//
			out.writeHeader(src, inflatedLength);
			out.write(buf, 0, (int) dataLength);
		} else {
			// Now we are committed to sending the object. As we spool it out,
			// check its CRC32 code to make sure there wasn't corruption between
			// the verification we did above, and us actually outputting it.
			//
			out.writeHeader(src, inflatedLength);
			long pos = dataOffset;
			long cnt = dataLength;
			while (cnt > 0) {
				final int n = (int) Math.min(cnt, buf.length);
				readFully(pos, buf, 0, n, curs);
				crc2.update(buf, 0, n);
				out.write(buf, 0, n);
				pos += n;
				cnt -= n;
			}
			if (crc2.getValue() != expectedCRC) {
				throw new CorruptObjectException(MessageFormat.format(JGitText
						.get().objectAtHasBadZlibStream, src.copyOffset,
						getPackFile()));
			}
		}
	}

