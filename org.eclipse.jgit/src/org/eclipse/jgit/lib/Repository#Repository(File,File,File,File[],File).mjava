	/**
	 * Construct a representation of a Git repository using the given parameters
	 * possibly overriding default conventions.
	 *
	 * @param d
	 *            GIT_DIR (the location of the repository metadata). May be null
	 *            for default value in which case it depends on GIT_WORK_TREE.
	 * @param workTree
	 *            GIT_WORK_TREE (the root of the checkout). May be null for
	 *            default value if GIT_DIR is
	 * @param objectDir
	 *            GIT_OBJECT_DIRECTORY (where objects and are stored). May be
	 *            null for default value. Relative names ares resolved against
	 *            GIT_WORK_TREE
	 * @param alternateObjectDir
	 *            GIT_ALTERNATE_OBJECT_DIRECTORIES (where more objects are read
	 *            from). May be null for default value. Relative names ares
	 *            resolved against GIT_WORK_TREE
	 * @param indexFile
	 *            GIT_INDEX_FILE (the location of the index file). May be null
	 *            for default value. Relative names ares resolved against
	 *            GIT_WORK_TREE.
	 * @throws IOException
	 *             the repository appears to already exist but cannot be
	 *             accessed.
	 */
	public Repository(final File d, final File workTree, final File objectDir,
			final File[] alternateObjectDir, final File indexFile) throws IOException {

		if (workTree != null) {
			workDir = workTree;
			if (d == null)
				gitDir = new File(workTree, ".git");
			else
				gitDir = d;
		} else {
			if (d != null)
				gitDir = d;
			else
				throw new IllegalArgumentException("Either GIT_DIR or GIT_WORK_TREE must be passed to Repository constructor");
		}

		final FileBasedConfig userConfig;
		userConfig = SystemReader.getInstance().openUserConfig();
		try {
			userConfig.load();
		} catch (ConfigInvalidException e1) {
			IOException e2 = new IOException("User config file "
					+ userConfig.getFile().getAbsolutePath() + " invalid: "
					+ e1);
			e2.initCause(e1);
			throw e2;
		}
		config = new RepositoryConfig(userConfig, FS.resolve(gitDir, "config"));

		try {
			getConfig().load();
		} catch (ConfigInvalidException e1) {
			IOException e2 = new IOException("Unknown repository format");
			e2.initCause(e1);
			throw e2;
		}

		if (workDir == null) {
			if (d != null) {
				// Only read core.worktree if GIT_DIR is set explicitly. See
				// git-config(1).
				String workTreeConfig = getConfig().getString("core", null, "worktree");
				if (workTreeConfig != null) {
					workDir = FS.resolve(d, workTreeConfig);
				} else {
					workDir = gitDir.getParentFile();
				}
			}
		}

		refs = new RefDatabase(this);
		if (objectDir != null)
			objectDatabase = new ObjectDirectory(FS.resolve(objectDir, ""),
					alternateObjectDir);
		else
			objectDatabase = new ObjectDirectory(FS.resolve(gitDir, "objects"),
					alternateObjectDir);

		if (indexFile != null)
			this.indexFile = indexFile;
		else
			this.indexFile = new File(gitDir, "index");

		if (objectDatabase.exists()) {
			final String repositoryFormatVersion = getConfig().getString(
					"core", null, "repositoryFormatVersion");
			if (!"0".equals(repositoryFormatVersion)) {
				throw new IOException("Unknown repository format \""
						+ repositoryFormatVersion + "\"; expected \"0\".");
			}
		}
	}

