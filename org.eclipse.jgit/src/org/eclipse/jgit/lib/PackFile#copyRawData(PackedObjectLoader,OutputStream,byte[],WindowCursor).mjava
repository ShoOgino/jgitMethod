	final void copyRawData(final PackedObjectLoader loader,
			final OutputStream out, final byte buf[], final WindowCursor curs)
			throws IOException {
		final long objectOffset = loader.objectOffset;
		final long dataOffset = objectOffset + loader.headerSize;
		final long sz = findEndOffset(objectOffset) - dataOffset;
		final PackIndex idx = idx();

		if (idx.hasCRC32Support()) {
			final CRC32 crc = new CRC32();
			int headerCnt = loader.headerSize;
			while (headerCnt > 0) {
				final int toRead = Math.min(headerCnt, buf.length);
				readFully(objectOffset, buf, 0, toRead, curs);
				crc.update(buf, 0, toRead);
				headerCnt -= toRead;
			}
			final CheckedOutputStream crcOut = new CheckedOutputStream(out, crc);
			copyToStream(dataOffset, buf, sz, crcOut, curs);
			final long computed = crc.getValue();

			final ObjectId id = findObjectForOffset(objectOffset);
			final long expected = idx.findCRC32(id);
			if (computed != expected)
				throw new CorruptObjectException(MessageFormat.format(
						JGitText.get().objectAtHasBadZlibStream, objectOffset, getPackFile()));
		} else {
			try {
				curs.inflateVerify(this, dataOffset);
			} catch (DataFormatException dfe) {
				final CorruptObjectException coe;
				coe = new CorruptObjectException(MessageFormat.format(
						JGitText.get().objectAtHasBadZlibStream, objectOffset, getPackFile()));
				coe.initCause(dfe);
				throw coe;
			}
			copyToStream(dataOffset, buf, sz, out, curs);
		}
	}

