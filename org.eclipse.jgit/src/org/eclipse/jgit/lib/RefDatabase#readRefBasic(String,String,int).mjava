	private synchronized Ref readRefBasic(final String origName,
			final String name, final int depth) throws IOException {
		// Prefer loose ref to packed ref as the loose
		// file can be more up-to-date than a packed one.
		//
		Ref ref = looseRefs.get(origName);
		final File loose = fileForRef(name);
		final long mtime = loose.lastModified();
		if (ref != null) {
			Long cachedlastModified = looseRefsMTime.get(name);
			if (cachedlastModified != null && cachedlastModified == mtime) {
				if (packedRefs.containsKey(origName))
					return new Ref(Storage.LOOSE_PACKED, origName, ref
							.getObjectId(), ref.getPeeledObjectId(), ref
							.isPeeled());
				else
					return ref;
			}
			looseRefs.remove(origName);
			looseRefsMTime.remove(origName);
		}

		if (mtime == 0) {
			// If last modified is 0 the file does not exist.
			// Try packed cache.
			//
			ref = packedRefs.get(name);
			if (ref != null)
				if (!ref.getOrigName().equals(origName))
					ref = new Ref(Storage.LOOSE_PACKED, origName, name, ref.getObjectId());
			return ref;
		}

		String line = null;
		try {
			Long cachedlastModified = looseRefsMTime.get(name);
			if (cachedlastModified != null && cachedlastModified == mtime) {
				line = looseSymRefs.get(name);
			}
			if (line == null) {
				line = readLine(loose);
				looseRefsMTime.put(name, mtime);
				looseSymRefs.put(name, line);
			}
		} catch (FileNotFoundException notLoose) {
			return packedRefs.get(name);
		}

		if (line == null || line.length() == 0) {
			looseRefs.remove(origName);
			looseRefsMTime.remove(origName);
			return new Ref(Ref.Storage.LOOSE, origName, name, null);
		}

		if (line.startsWith("ref: ")) {
			if (depth >= 5) {
				throw new IOException("Exceeded maximum ref depth of " + depth
						+ " at " + name + ".  Circular reference?");
			}

			final String target = line.substring("ref: ".length());
			Ref r = readRefBasic(target, target, depth + 1);
			Long cachedMtime = looseRefsMTime.get(name);
			if (cachedMtime != null && cachedMtime != mtime)
				setModified();
			looseRefsMTime.put(name, mtime);
			if (r == null)
				return new Ref(Ref.Storage.LOOSE, origName, target, null);
			if (!origName.equals(r.getName()))
				r = new Ref(Ref.Storage.LOOSE_PACKED, origName, r.getName(), r.getObjectId(), r.getPeeledObjectId(), true);
			return r; 
		}

		setModified();

		final ObjectId id;
		try {
			id = ObjectId.fromString(line);
		} catch (IllegalArgumentException notRef) {
			throw new IOException("Not a ref: " + name + ": " + line);
		}

		Storage storage;
		if (packedRefs.containsKey(name))
			storage = Ref.Storage.LOOSE_PACKED;
		else
			storage = Ref.Storage.LOOSE;
		ref = new Ref(storage, name, id);
		looseRefs.put(name, ref);
		looseRefsMTime.put(name, mtime);

		if (!origName.equals(name)) {
			ref = new Ref(Ref.Storage.LOOSE, origName, name, id);
			looseRefs.put(origName, ref);
		}

		return ref;
	}

