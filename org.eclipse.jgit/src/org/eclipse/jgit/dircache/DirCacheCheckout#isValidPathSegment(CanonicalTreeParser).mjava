	private static boolean isValidPathSegment(CanonicalTreeParser t) {
		boolean isWindows = "Windows".equals(SystemReader.getInstance()
				.getProperty("os.name"));
		boolean isOSX = "Mac OS X".equals(SystemReader.getInstance()
				.getProperty("os.name"));
		boolean ignCase = isOSX || isWindows;

		int ptr = t.getNameOffset();
		byte[] raw = t.getEntryPathBuffer();
		int end = ptr + t.getNameLength();

		// Validate path component at this level of the tree
		int start = ptr;
		while (ptr < end) {
			if (raw[ptr] == '/')
				return false;
			if (isWindows) {
				if (raw[ptr] == '\\')
					return false;
				if (raw[ptr] == ':')
					return false;
			}
			ptr++;
		}
		// '.' and '.'' are invalid here
		if (ptr - start == 1) {
			if (raw[start] == '.')
				return false;
		} else if (ptr - start == 2) {
			if (raw[start] == '.')
				if (raw[start + 1] == '.')
					return false;
		} else if (ptr - start == 4) {
			// .git (possibly case insensitive) is disallowed
			if (raw[start] == '.')
				if (raw[start + 1] == 'g' || (ignCase && raw[start + 1] == 'G'))
					if (raw[start + 2] == 'i'
							|| (ignCase && raw[start + 2] == 'I'))
						if (raw[start + 3] == 't'
								|| (ignCase && raw[start + 3] == 'T'))
							return false;
		}
		if (isWindows) {
			// Space or period at end of file name is ignored by Windows.
			// Treat this as a bad path for now. We may want to handle
			// this as case insensitivity in the future.
			if (raw[ptr - 1] == '.' || raw[ptr - 1] == ' ')
				return false;
			int i;
			// Bad names, eliminate suffix first
			for (i = start; i < ptr; ++i)
				if (raw[i] == '.')
					break;
			int len = i - start;
			if (len == 3 || len == 4) {
				for (int j = 0; j < forbidden.length; ++j) {
					if (forbidden[j].length == len) {
						if (toUpper(raw[start]) < forbidden[j][0])
							break;
						int k;
						for (k = 0; k < len; ++k) {
							if (toUpper(raw[start + k]) != forbidden[j][k])
								break;
						}
						if (k == len)
							return false;
					}
				}
			}
		}

		return true;
	}

