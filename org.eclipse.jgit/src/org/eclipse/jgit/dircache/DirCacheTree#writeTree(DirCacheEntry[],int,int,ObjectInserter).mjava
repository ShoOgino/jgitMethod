	/**
	 * Write (if necessary) this tree to the object store.
	 *
	 * @param cache
	 *            the complete cache from DirCache.
	 * @param cIdx
	 *            first position of <code>cache</code> that is a member of this
	 *            tree. The path of <code>cache[cacheIdx].path</code> for the
	 *            range <code>[0,pathOff-1)</code> matches the complete path of
	 *            this tree, from the root of the repository.
	 * @param pathOffset
	 *            number of bytes of <code>cache[cacheIdx].path</code> that
	 *            matches this tree's path. The value at array position
	 *            <code>cache[cacheIdx].path[pathOff-1]</code> is always '/' if
	 *            <code>pathOff</code> is > 0.
	 * @param ow
	 *            the writer to use when serializing to the store.
	 * @return identity of this tree.
	 * @throws UnmergedPathException
	 *             one or more paths contain higher-order stages (stage > 0),
	 *             which cannot be stored in a tree object.
	 * @throws IOException
	 *             an unexpected error occurred writing to the object store.
	 */
	ObjectId writeTree(final DirCacheEntry[] cache, int cIdx,
			final int pathOffset, final ObjectInserter ow)
			throws UnmergedPathException, IOException {
		if (id == null) {
			final int endIdx = cIdx + entrySpan;
			final int size = computeSize(cache, cIdx, pathOffset, ow);
			final ByteArrayOutputStream out = new ByteArrayOutputStream(size);
			int childIdx = 0;
			int entryIdx = cIdx;

			while (entryIdx < endIdx) {
				final DirCacheEntry e = cache[entryIdx];
				final byte[] ep = e.path;
				if (childIdx < childCnt) {
					final DirCacheTree st = children[childIdx];
					if (st.contains(ep, pathOffset, ep.length)) {
						FileMode.TREE.copyTo(out);
						out.write(' ');
						out.write(st.encodedName);
						out.write(0);
						st.id.copyRawTo(out);

						entryIdx += st.entrySpan;
						childIdx++;
						continue;
					}
				}

				e.getFileMode().copyTo(out);
				out.write(' ');
				out.write(ep, pathOffset, ep.length - pathOffset);
				out.write(0);
				out.write(e.idBuffer(), e.idOffset(), OBJECT_ID_LENGTH);
				entryIdx++;
			}

			id = ow.insert(Constants.OBJ_TREE, out.toByteArray());
		}
		return id;
	}

