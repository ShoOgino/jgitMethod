	/**
	 * Executes the {@code Diff} command with all the options and parameters
	 * collected by the setter methods (e.g. {@link #setCached(boolean)} of this
	 * class. Each instance of this class should only be used for one invocation
	 * of the command. Don't call this method twice on an instance.
	 *
	 * @return a DiffEntry for each path which is different
	 */
	public List<DiffEntry> call() throws GitAPIException, IOException {
		final DiffFormatter diffFmt = new DiffFormatter(
				new BufferedOutputStream(out));
		diffFmt.setRepository(repo);
		diffFmt.setProgressMonitor(monitor);
		try {
			if (cached) {
				if (oldTree == null) {
					ObjectId head = repo.resolve(HEAD + "^{tree}");
					if (head == null)
						throw new NoHeadException(JGitText.get().cannotReadTree);
					CanonicalTreeParser p = new CanonicalTreeParser();
					ObjectReader reader = repo.newObjectReader();
					try {
						p.reset(reader, head);
					} finally {
						reader.release();
					}
					oldTree = p;
				}
				newTree = new DirCacheIterator(repo.readDirCache());
			} else {
				if (oldTree == null)
					oldTree = new DirCacheIterator(repo.readDirCache());
				if (newTree == null)
					newTree = new FileTreeIterator(repo);
			}

			diffFmt.setPathFilter(pathFilter);
			if (contextLines >= 0)
				diffFmt.setContext(contextLines);
			if (destinationPrefix != null)
				diffFmt.setNewPrefix(destinationPrefix);
			if (sourcePrefix != null)
				diffFmt.setOldPrefix(sourcePrefix);

			List<DiffEntry> result = diffFmt.scan(oldTree, newTree);
			if (showNameAndStatusOnly) {
				return result;
			} else {
				diffFmt.format(result);
				diffFmt.flush();
				return result;
			}
		} finally {
			diffFmt.release();
		}
	}

