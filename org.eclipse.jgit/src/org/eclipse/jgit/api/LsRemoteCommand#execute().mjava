	protected Map<String, Ref> execute() throws GitAPIException,
			InvalidRemoteException,
			org.eclipse.jgit.api.errors.TransportException {
		checkCallable();

		Transport transport = null;
		FetchConnection fc = null;
		try {
			if (repo != null)
				transport = Transport.open(repo, remote);
			else
				transport = Transport.open(new URIish(remote));
			transport.setOptionUploadPack(uploadPack);
			configure(transport);
			Collection<RefSpec> refSpecs = new ArrayList<RefSpec>(1);
			if (tags)
				refSpecs.add(new RefSpec(
						"refs/tags/*:refs/remotes/origin/tags/*")); //$NON-NLS-1$
			if (heads)
				refSpecs.add(new RefSpec("refs/heads/*:refs/remotes/origin/*")); //$NON-NLS-1$
			Collection<Ref> refs;
			Map<String, Ref> refmap = new HashMap<String, Ref>();
			fc = transport.openFetch();
			refs = fc.getRefs();
			if (refSpecs.isEmpty())
				for (Ref r : refs)
					refmap.put(r.getName(), r);
			else
				for (Ref r : refs)
					for (RefSpec rs : refSpecs)
						if (rs.matchSource(r)) {
							refmap.put(r.getName(), r);
							break;
						}
			return refmap;
		} catch (URISyntaxException e) {
			throw new InvalidRemoteException(MessageFormat.format(
					JGitText.get().invalidRemote, remote));
		} catch (NotSupportedException e) {
			throw new JGitInternalException(
					JGitText.get().exceptionCaughtDuringExecutionOfLsRemoteCommand,
					e);
		} catch (TransportException e) {
			throw new org.eclipse.jgit.api.errors.TransportException(
					e.getMessage(),
					e);
		} finally {
			if (fc != null)
				fc.close();
			if (transport != null)
				transport.close();
		}
	}

