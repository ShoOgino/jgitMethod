	/**
	 * Checkout paths into index and working directory
	 *
	 * @return this instance
	 * @throws IOException
	 * @throws RefNotFoundException
	 */
	protected CheckoutCommand checkoutPaths() throws IOException,
			RefNotFoundException {
		RevWalk revWalk = new RevWalk(repo);
		DirCache dc = repo.lockDirCache();
		try {
			DirCacheEditor editor = dc.editor();
			TreeWalk startWalk = new TreeWalk(revWalk.getObjectReader());
			startWalk.setRecursive(true);
			if (!checkoutAllPaths)
				startWalk.setFilter(PathFilterGroup.createFromStrings(paths));
			boolean checkoutIndex = startCommit == null && startPoint == null;
			if (!checkoutIndex)
				startWalk.addTree(revWalk.parseCommit(getStartPoint())
						.getTree());
			else
				startWalk.addTree(new DirCacheIterator(dc));

			final File workTree = repo.getWorkTree();
			final ObjectReader r = repo.getObjectDatabase().newReader();
			try {
				while (startWalk.next()) {
					final ObjectId blobId = startWalk.getObjectId(0);
					final FileMode mode = startWalk.getFileMode(0);
					editor.add(new PathEdit(startWalk.getPathString()) {
						public void apply(DirCacheEntry ent) {
							ent.setObjectId(blobId);
							ent.setFileMode(mode);
							File file = new File(workTree, ent.getPathString());
							File parentDir = file.getParentFile();
							try {
								FileUtils.mkdirs(parentDir, true);
								DirCacheCheckout.checkoutEntry(repo, file, ent, r);
							} catch (IOException e) {
								throw new JGitInternalException(
										MessageFormat.format(
												JGitText.get().checkoutConflictWithFile,
												ent.getPathString()), e);
							}
						}
					});
				}
				editor.commit();
			} finally {
				startWalk.release();
				r.release();
			}
		} finally {
			dc.unlock();
			revWalk.release();
		}
		return this;
	}

