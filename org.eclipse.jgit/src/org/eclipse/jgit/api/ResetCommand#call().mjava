	/**
	 * Executes the {@code Reset} command. Each instance of this class should
	 * only be used for one invocation of the command. Don't call this method
	 * twice on an instance.
	 *
	 * @return the Ref after reset
	 * @throws GitAPIException
	 */
	public Ref call() throws GitAPIException, CheckoutConflictException {
		checkCallable();

		Ref r;
		RevCommit commit;

		try {
			RepositoryState state = repo.getRepositoryState();
			final boolean merging = state.equals(RepositoryState.MERGING)
					|| state.equals(RepositoryState.MERGING_RESOLVED);
			final boolean cherryPicking = state
					.equals(RepositoryState.CHERRY_PICKING)
					|| state.equals(RepositoryState.CHERRY_PICKING_RESOLVED);

			// resolve the ref to a commit
			final ObjectId commitId;
			try {
				commitId = repo.resolve(ref + "^{commit}");
				if (commitId == null) {
					// @TODO throw an InvalidRefNameException. We can't do that
					// now because this would break the API
					throw new JGitInternalException("Invalid ref " + ref
							+ " specified");
				}
			} catch (IOException e) {
				throw new JGitInternalException(
						MessageFormat.format(JGitText.get().cannotRead, ref),
						e);
			}
			RevWalk rw = new RevWalk(repo);
			try {
				commit = rw.parseCommit(commitId);
			} catch (IOException e) {
				throw new JGitInternalException(
						MessageFormat.format(
						JGitText.get().cannotReadCommit, commitId.toString()),
						e);
			} finally {
				rw.release();
			}

			if (!filepaths.isEmpty()) {
				// reset [commit] -- paths
				resetIndexForPaths(commit);
				setCallable(false);
				return repo.getRef(Constants.HEAD);
			}

			// write the ref
			final RefUpdate ru = repo.updateRef(Constants.HEAD);
			ru.setNewObjectId(commitId);

			String refName = Repository.shortenRefName(ref);
			String message = refName + ": updating " + Constants.HEAD; //$NON-NLS-1$
			ru.setRefLogMessage(message, false);
			if (ru.forceUpdate() == RefUpdate.Result.LOCK_FAILURE)
				throw new JGitInternalException(MessageFormat.format(
						JGitText.get().cannotLock, ru.getName()));

			ObjectId origHead = ru.getOldObjectId();
			if (origHead != null)
				repo.writeOrigHead(origHead);

			switch (mode) {
				case HARD:
					checkoutIndex(commit);
					break;
				case MIXED:
					resetIndex(commit);
					break;
				case SOFT: // do nothing, only the ref was changed
					break;
				case KEEP: // TODO
				case MERGE: // TODO
					throw new UnsupportedOperationException();

			}

			if (mode != ResetType.SOFT) {
				if (merging)
					resetMerge();
				else if (cherryPicking)
					resetCherryPick();
				else if (repo.readSquashCommitMsg() != null)
					repo.writeSquashCommitMsg(null /* delete */);
			}

			setCallable(false);
			r = ru.getRef();
		} catch (IOException e) {
			throw new JGitInternalException(
					JGitText.get().exceptionCaughtDuringExecutionOfResetCommand,
					e);
		}

		return r;
	}

