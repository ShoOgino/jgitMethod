	private DirCache createTemporaryIndex(ObjectId headId, DirCache index)
			throws IOException {
		ObjectInserter inserter = null;

		// get DirCacheEditor to modify the index if required
		DirCacheEditor dcEditor = index.editor();

		// get DirCacheBuilder for newly created in-core index to build a
		// temporary index for this commit
		DirCache inCoreIndex = DirCache.newInCore();
		DirCacheBuilder dcBuilder = inCoreIndex.builder();

		onlyProcessed = new boolean[only.size()];
		boolean emptyCommit = true;

		TreeWalk treeWalk = new TreeWalk(repo);
		int dcIdx = treeWalk.addTree(new DirCacheIterator(index));
		int fIdx = treeWalk.addTree(new FileTreeIterator(repo));
		int hIdx = -1;
		if (headId != null)
			hIdx = treeWalk.addTree(new RevWalk(repo).parseTree(headId));
		treeWalk.setRecursive(true);

		while (treeWalk.next()) {
			String path = treeWalk.getPathString();
			// check if current entry's path matches a specified path
			int pos = lookupOnly(path);

			CanonicalTreeParser hTree = null;
			if (hIdx != -1)
				hTree = treeWalk.getTree(hIdx, CanonicalTreeParser.class);

			if (pos >= 0) {
				// include entry in commit

				DirCacheIterator dcTree = treeWalk.getTree(dcIdx,
						DirCacheIterator.class);
				FileTreeIterator fTree = treeWalk.getTree(fIdx,
						FileTreeIterator.class);

				// check if entry refers to a tracked file
				boolean tracked = dcTree != null || hTree != null;
				if (!tracked)
					break;

				if (fTree != null) {
					// create a new DirCacheEntry with data retrieved from disk
					final DirCacheEntry dcEntry = new DirCacheEntry(path);
					long entryLength = fTree.getEntryLength();
					dcEntry.setLength(entryLength);
					dcEntry.setLastModified(fTree.getEntryLastModified());
					dcEntry.setFileMode(fTree.getIndexFileMode(dcTree));

					boolean objectExists = (dcTree != null && fTree
							.idEqual(dcTree))
							|| (hTree != null && fTree.idEqual(hTree));
					if (objectExists) {
						dcEntry.setObjectId(fTree.getEntryObjectId());
					} else {
						if (FileMode.GITLINK.equals(dcEntry.getFileMode())) {
							// Do not check the content of submodule entries
							// Use the old entry information instead.
							dcEntry.copyMetaData(index.getEntry(dcEntry
									.getPathString()));
						} else {
							// insert object
							if (inserter == null)
								inserter = repo.newObjectInserter();

							InputStream inputStream = fTree.openEntryStream();
							try {
								dcEntry.setObjectId(inserter.insert(
										Constants.OBJ_BLOB, entryLength,
										inputStream));
							} finally {
								inputStream.close();
							}
						}
					}

					// update index
					dcEditor.add(new PathEdit(path) {
						@Override
						public void apply(DirCacheEntry ent) {
							ent.copyMetaData(dcEntry);
						}
					});
					// add to temporary in-core index
					dcBuilder.add(dcEntry);

					if (emptyCommit && (hTree == null || !hTree.idEqual(fTree)))
						// this is a change
						emptyCommit = false;
				} else {
					// if no file exists on disk, remove entry from index and
					// don't add it to temporary in-core index
					dcEditor.add(new DeletePath(path));

					if (emptyCommit && hTree != null)
						// this is a change
						emptyCommit = false;
				}

				// keep track of processed path
				onlyProcessed[pos] = true;
			} else {
				// add entries from HEAD for all other paths
				if (hTree != null) {
					// create a new DirCacheEntry with data retrieved from HEAD
					final DirCacheEntry dcEntry = new DirCacheEntry(path);
					dcEntry.setObjectId(hTree.getEntryObjectId());
					dcEntry.setFileMode(hTree.getEntryFileMode());

					// add to temporary in-core index
					dcBuilder.add(dcEntry);
				}
			}
		}

		// there must be no unprocessed paths left at this point; otherwise an
		// untracked or unknown path has been specified
		for (int i = 0; i < onlyProcessed.length; i++)
			if (!onlyProcessed[i])
				throw new JGitInternalException(MessageFormat.format(
						JGitText.get().entryNotFoundByPath, only.get(i)));

		// there must be at least one change
		if (emptyCommit)
			throw new JGitInternalException(JGitText.get().emptyCommit);

		// update index
		dcEditor.commit();
		// finish temporary in-core index used for this commit
		dcBuilder.finish();
		return inCoreIndex;
	}

