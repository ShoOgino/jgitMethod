	/**
	 * @throws RefAlreadyExistsException
	 *             when trying to create (without force) a branch with a name
	 *             that already exists
	 * @throws RefNotFoundException
	 *             if the start point or branch can not be found
	 * @throws InvalidRefNameException
	 *             if the provided name is <code>null</code> or otherwise
	 *             invalid
	 * @return the newly created branch
	 */
	public Ref call() throws JGitInternalException, RefAlreadyExistsException,
			RefNotFoundException, InvalidRefNameException {
		checkCallable();
		processOptions();
		try {

			if (createBranch) {
				Git git = new Git(repo);
				CreateBranchCommand command = git.branchCreate();
				command.setName(name);
				command.setStartPoint(getStartPoint().name());
				if (upstreamMode != null)
					command.setUpstreamMode(upstreamMode);
				command.call();
			}

			RevWalk revWalk = new RevWalk(repo);
			Ref headRef = repo.getRef(Constants.HEAD);
			RevCommit headCommit = revWalk.parseCommit(headRef.getObjectId());
			String refLogMessage = "checkout: moving from "
					+ headRef.getTarget().getName();
			ObjectId branch = repo.resolve(name);

			if (branch == null)
				throw new RefNotFoundException(MessageFormat.format(JGitText
						.get().refNotResolved, name));

			RevCommit newCommit = revWalk.parseCommit(branch);

			DirCacheCheckout dco = new DirCacheCheckout(repo, headCommit
					.getTree(), repo.lockDirCache(), newCommit.getTree());
			dco.setFailOnConflict(true);
			try {
				dco.checkout();
			} catch (CheckoutConflictException e) {
				List<File> fileList = new ArrayList<File>();
				for (String filePath : dco.getConflicts()) {
					fileList.add(new File(repo.getWorkTree(), filePath));
				}
				status = new CheckoutResult(Status.CONFLICTS, fileList);
				throw e;
			}
			Ref ref = repo.getRef(name);
			if (ref != null && !ref.getName().startsWith(Constants.R_HEADS))
				ref = null;
			RefUpdate refUpdate = repo.updateRef(Constants.HEAD, ref == null);
			refUpdate.setForceUpdate(force);
			refUpdate.setRefLogMessage(refLogMessage + "to "
					+ newCommit.getName(), false);
			Result updateResult;
			if (ref != null)
				updateResult = refUpdate.link(ref.getName());
			else {
				refUpdate.setNewObjectId(newCommit);
				updateResult = refUpdate.forceUpdate();
			}

			setCallable(false);

			boolean ok = false;
			switch (updateResult) {
			case NEW:
				ok = true;
				break;
			case NO_CHANGE:
			case FAST_FORWARD:
			case FORCED:
				ok = true;
				break;
			default:
				break;
			}

			if (!ok)
				throw new JGitInternalException(MessageFormat.format(JGitText
						.get().checkoutUnexpectedResult, updateResult.name()));

			if (!repo.isBare() && !dco.getToBeDeleted().isEmpty()) {
				List<File> fileList = new ArrayList<File>();
				for (String filePath : dco.getToBeDeleted()) {
					fileList.add(new File(repo.getWorkTree(), filePath));
				}
				status = new CheckoutResult(Status.NONDELETED, fileList);
			}
			else
				status = CheckoutResult.OK_RESULT;
			return ref;
		} catch (IOException ioe) {
			throw new JGitInternalException(ioe.getMessage(), ioe);
		} finally {
			if (status == null)
				status = CheckoutResult.ERROR_RESULT;
		}
	}

