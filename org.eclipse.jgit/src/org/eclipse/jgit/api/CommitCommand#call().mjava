	/**
	 * Executes the {@code commit} command with all the options and parameters
	 * collected by the setter methods of this class. Each instance of this
	 * class should only be used for one invocation of the command (means: one
	 * call to {@link #call()})
	 *
	 * @return a {@link RevCommit} object representing the successful commit.
	 * @throws NoHeadException
	 *             when called on a git repo without a HEAD reference
	 * @throws NoMessageException
	 *             when called without specifying a commit message
	 * @throws UnmergedPathsException
	 *             when the current index contained unmerged paths (conflicts)
	 * @throws ConcurrentRefUpdateException
	 *             when HEAD or branch ref is updated concurrently by someone
	 *             else
	 * @throws WrongRepositoryStateException
	 *             when repository is not in the right state for committing
	 */
	public RevCommit call() throws GitAPIException, NoHeadException,
			NoMessageException, UnmergedPathsException,
			ConcurrentRefUpdateException,
			WrongRepositoryStateException {
		checkCallable();

		RepositoryState state = repo.getRepositoryState();
		if (!state.canCommit())
			throw new WrongRepositoryStateException(MessageFormat.format(
					JGitText.get().cannotCommitOnARepoWithState, state.name()));
		processOptions(state);

		try {
			if (all && !repo.isBare() && repo.getWorkTree() != null) {
				Git git = new Git(repo);
				try {
					git.add()
							.addFilepattern(".") //$NON-NLS-1$
							.setUpdate(true).call();
				} catch (NoFilepatternException e) {
					// should really not happen
					throw new JGitInternalException(e.getMessage(), e);
				}
			}

			Ref head = repo.getRef(Constants.HEAD);
			if (head == null)
				throw new NoHeadException(
						JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);

			// determine the current HEAD and the commit it is referring to
			ObjectId headId = repo.resolve(Constants.HEAD + "^{commit}"); //$NON-NLS-1$
			if (headId == null && amend)
				throw new WrongRepositoryStateException(
						JGitText.get().commitAmendOnInitialNotPossible);

			if (headId != null)
				if (amend) {
					RevCommit previousCommit = new RevWalk(repo)
							.parseCommit(headId);
					RevCommit[] p = previousCommit.getParents();
					for (int i = 0; i < p.length; i++)
						parents.add(0, p[i].getId());
					if (author == null)
						author = previousCommit.getAuthorIdent();
				} else {
					parents.add(0, headId);
				}

			// lock the index
			DirCache index = repo.lockDirCache();
			try {
				if (!only.isEmpty())
					index = createTemporaryIndex(headId, index);

				ObjectInserter odi = repo.newObjectInserter();
				try {
					// Write the index as tree to the object database. This may
					// fail for example when the index contains unmerged paths
					// (unresolved conflicts)
					ObjectId indexTreeId = index.writeTree(odi);

					if (insertChangeId)
						insertChangeId(indexTreeId);

					// Create a Commit object, populate it and write it
					CommitBuilder commit = new CommitBuilder();
					commit.setCommitter(committer);
					commit.setAuthor(author);
					commit.setMessage(message);

					commit.setParentIds(parents);
					commit.setTreeId(indexTreeId);
					ObjectId commitId = odi.insert(commit);
					odi.flush();

					RevWalk revWalk = new RevWalk(repo);
					try {
						RevCommit revCommit = revWalk.parseCommit(commitId);
						RefUpdate ru = repo.updateRef(Constants.HEAD);
						ru.setNewObjectId(commitId);
						if (reflogComment != null) {
							ru.setRefLogMessage(reflogComment, false);
						} else {
							String prefix = amend ? "commit (amend): " //$NON-NLS-1$
									: "commit: ";
							ru.setRefLogMessage(
									prefix + revCommit.getShortMessage(), false);
						}
						if (headId != null)
							ru.setExpectedOldObjectId(headId);
						else
							ru.setExpectedOldObjectId(ObjectId.zeroId());
						Result rc = ru.forceUpdate();
						switch (rc) {
						case NEW:
						case FORCED:
						case FAST_FORWARD: {
							setCallable(false);
							if (state == RepositoryState.MERGING_RESOLVED) {
								// Commit was successful. Now delete the files
								// used for merge commits
								repo.writeMergeCommitMsg(null);
								repo.writeMergeHeads(null);
							} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {
								repo.writeMergeCommitMsg(null);
								repo.writeCherryPickHead(null);
							} else if (state == RepositoryState.REVERTING_RESOLVED) {
								repo.writeMergeCommitMsg(null);
								repo.writeRevertHead(null);
							}
							return revCommit;
						}
						case REJECTED:
						case LOCK_FAILURE:
							throw new ConcurrentRefUpdateException(JGitText
									.get().couldNotLockHEAD, ru.getRef(), rc);
						default:
							throw new JGitInternalException(MessageFormat
									.format(JGitText.get().updatingRefFailed,
											Constants.HEAD,
											commitId.toString(), rc));
						}
					} finally {
						revWalk.release();
					}
				} finally {
					odi.release();
				}
			} finally {
				index.unlock();
			}
		} catch (UnmergedPathException e) {
			throw new UnmergedPathsException(e);
		} catch (IOException e) {
			throw new JGitInternalException(
					JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);
		}
	}

