	/**
	 * Executes the {@code commit} command with all the options and parameters
	 * collected by the setter methods of this class. Each instance of this
	 * class should only be used for one invocation of the command (means: one
	 * call to {@link #call()})
	 *
	 * @return a {@link RevCommit} object representing the successful commit.
	 * @throws NoHeadException
	 *             when called on a git repo without a HEAD reference
	 * @throws NoMessageException
	 *             when called without specifying a commit message
	 * @throws UnmergedPathException
	 *             when the current index contained unmerged pathes (conflicts)
	 * @throws WrongRepositoryStateException
	 *             when repository is not in the right state for committing
	 * @throws JGitInternalException
	 *             a low-level exception of JGit has occurred. The original
	 *             exception can be retrieved by calling
	 *             {@link Exception#getCause()}. Expect only
	 *             {@code IOException's} to be wrapped. Subclasses of
	 *             {@link IOException} (e.g. {@link UnmergedPathException}) are
	 *             typically not wrapped here but thrown as original exception
	 */
	public RevCommit call() throws NoHeadException, NoMessageException,
			UnmergedPathException, ConcurrentRefUpdateException,
			JGitInternalException, WrongRepositoryStateException {
		checkCallable();

		RepositoryState state = repo.getRepositoryState();
		if (!state.canCommit())
			throw new WrongRepositoryStateException(MessageFormat.format(
					JGitText.get().cannotCommitOnARepoWithState, state.name()));
		processOptions(state);

		try {
			if (all && !repo.isBare() && repo.getWorkTree() != null) {
				Git git = new Git(repo);
				try {
					git.add()
							.addFilepattern(".")
							.setUpdate(true).call();
				} catch (NoFilepatternException e) {
					// should really not happen
					throw new JGitInternalException(e.getMessage(), e);
				}
			}

			Ref head = repo.getRef(Constants.HEAD);
			if (head == null)
				throw new NoHeadException(
						JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);

			// determine the current HEAD and the commit it is referring to
			ObjectId headId = repo.resolve(Constants.HEAD + "^{commit}");
			if (headId != null)
				parents.add(0, headId);

			// lock the index
			DirCache index = repo.lockDirCache();
			try {
				ObjectInserter odi = repo.newObjectInserter();
				try {
					// Write the index as tree to the object database. This may
					// fail for example when the index contains unmerged paths
					// (unresolved conflicts)
					ObjectId indexTreeId = index.writeTree(odi);

					// Create a Commit object, populate it and write it
					CommitBuilder commit = new CommitBuilder();
					commit.setCommitter(committer);
					commit.setAuthor(author);
					commit.setMessage(message);

					commit.setParentIds(parents);
					commit.setTreeId(indexTreeId);
					ObjectId commitId = odi.insert(commit);
					odi.flush();

					RevWalk revWalk = new RevWalk(repo);
					try {
						RevCommit revCommit = revWalk.parseCommit(commitId);
						RefUpdate ru = repo.updateRef(Constants.HEAD);
						ru.setNewObjectId(commitId);
						ru.setRefLogMessage("commit : "
								+ revCommit.getShortMessage(), false);

						ru.setExpectedOldObjectId(headId);
						Result rc = ru.update();
						switch (rc) {
						case NEW:
						case FAST_FORWARD: {
							setCallable(false);
							if (state == RepositoryState.MERGING_RESOLVED) {
								// Commit was successful. Now delete the files
								// used for merge commits
								repo.writeMergeCommitMsg(null);
								repo.writeMergeHeads(null);
							}
							return revCommit;
						}
						case REJECTED:
						case LOCK_FAILURE:
							throw new ConcurrentRefUpdateException(JGitText
									.get().couldNotLockHEAD, ru.getRef(), rc);
						default:
							throw new JGitInternalException(MessageFormat
									.format(JGitText.get().updatingRefFailed,
											Constants.HEAD,
											commitId.toString(), rc));
						}
					} finally {
						revWalk.release();
					}
				} finally {
					odi.release();
				}
			} finally {
				index.unlock();
			}
		} catch (UnmergedPathException e) {
			// since UnmergedPathException is a subclass of IOException
			// which should not be wrapped by a JGitInternalException we
			// have to catch and re-throw it here
			throw e;
		} catch (IOException e) {
			throw new JGitInternalException(
					JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);
		}
	}

