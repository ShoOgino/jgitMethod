	/**
	 * Executes the {@code commit} command with all the options and parameters
	 * collected by the setter methods of this class. Each instance of this
	 * class should only be used for one invocation of the command (means: one
	 * call to {@link #call()})
	 *
	 * @return a {@link Commit} object representing the successful commit
	 * @throws NoHeadException
	 *             when called on a git repo without a HEAD reference
	 * @throws NoMessageException
	 *             when called without specifying a commit message
	 * @throws UnmergedPathException
	 *             when the current index contained unmerged pathes (conflicts)
	 * @throws JGitInternalException
	 *             a low-level exception of JGit has occurred. The original
	 *             exception can be retrieved by calling
	 *             {@link Exception#getCause()}. Expect only
	 *             {@code IOException's} to be wrapped. Subclasses of
	 *             {@link IOException} (e.g. {@link UnmergedPathException}) are
	 *             typically not wrapped here but thrown as original exception
	 */
	public RevCommit call() throws NoHeadException, NoMessageException,
			UnmergedPathException, ConcurrentRefUpdateException,
			JGitInternalException {
		checkCallable();
		processOptions();

		try {
			Ref head = repo.getRef(Constants.HEAD);
			if (head == null)
				throw new NoHeadException(
						JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);

			// determine the current HEAD and the commit it is referring to
			ObjectId parentID = repo.resolve(Constants.HEAD + "^{commit}");

			// lock the index
			DirCache index = DirCache.lock(repo);
			try {
				ObjectWriter repoWriter = new ObjectWriter(repo);

				// Write the index as tree to the object database. This may fail
				// for example when the index contains unmerged pathes
				// (unresolved conflicts)
				ObjectId indexTreeId = index.writeTree(repoWriter);

				// Create a Commit object, populate it and write it
				Commit commit = new Commit(repo);
				commit.setCommitter(committer);
				commit.setAuthor(author);
				commit.setMessage(message);
				if (parentID != null)
					commit.setParentIds(new ObjectId[] { parentID });
				commit.setTreeId(indexTreeId);
				ObjectId commitId = repoWriter.writeCommit(commit);

				RevCommit revCommit = new RevWalk(repo).parseCommit(commitId);
				RefUpdate ru = repo.updateRef(Constants.HEAD);
				ru.setNewObjectId(commitId);
				ru.setRefLogMessage("commit : " + revCommit.getShortMessage(),
						false);

				ru.setExpectedOldObjectId(parentID);
				Result rc = ru.update();
				switch (rc) {
				case NEW:
				case FAST_FORWARD:
					setCallable(false);
					return revCommit;
				case REJECTED:
				case LOCK_FAILURE:
					throw new ConcurrentRefUpdateException(
							JGitText.get().couldNotLockHEAD, ru.getRef(), rc);
				default:
					throw new JGitInternalException(MessageFormat.format(
							JGitText.get().updatingRefFailed
							, Constants.HEAD, commitId.toString(), rc));
				}
			} finally {
				index.unlock();
			}
		} catch (UnmergedPathException e) {
			// since UnmergedPathException is a subclass of IOException
			// which should not be wrapped by a JGitInternalException we
			// have to catch and re-throw it here
			throw e;
		} catch (IOException e) {
			throw new JGitInternalException(
					JGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);
		}
	}

