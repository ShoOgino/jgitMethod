	/**
	 * Executes the {@code fetch} command with all the options and parameters
	 * collected by the setter methods of this class. Each instance of this
	 * class should only be used for one invocation of the command (means: one
	 * call to {@link #call()})
	 *
	 * @return a {@link FetchResult} object representing the successful fetch
	 *         result
	 * @throws InvalidRemoteException
	 *             when called with an invalid remote uri
	 * @throws JGitInternalException
	 *             a low-level exception of JGit has occurred. The original
	 *             exception can be retrieved by calling
	 *             {@link Exception#getCause()}.
	 */
	public FetchResult call() throws JGitInternalException,
			InvalidRemoteException {
		checkCallable();

		try {
			Transport transport = Transport.open(repo, remote);
			try {
				transport.setCheckFetchedObjects(checkFetchedObjects);
				transport.setRemoveDeletedRefs(removeDeletedRefs);
				transport.setTimeout(timeout);
				transport.setDryRun(dryRun);
				if (tagOption != null)
					transport.setTagOpt(tagOption);
				transport.setFetchThin(thin);
				if (credentialsProvider != null)
					transport.setCredentialsProvider(credentialsProvider);
				if (transportConfigCallback != null)
					transportConfigCallback.configure(transport);

				FetchResult result = transport.fetch(monitor, refSpecs);
				return result;
			} finally {
				transport.close();
			}
		} catch (NoRemoteRepositoryException e) {
			throw new InvalidRemoteException(MessageFormat.format(
					JGitText.get().invalidRemote, remote), e);
		} catch (TransportException e) {
			throw new JGitInternalException(
					JGitText.get().exceptionCaughtDuringExecutionOfFetchCommand,
					e);
		} catch (URISyntaxException e) {
			throw new InvalidRemoteException(MessageFormat.format(
					JGitText.get().invalidRemote, remote));
		} catch (NotSupportedException e) {
			throw new JGitInternalException(
					JGitText.get().exceptionCaughtDuringExecutionOfFetchCommand,
					e);
		}

	}

