	/**
	 * Executes the {@code Rebase} command with all the options and parameters
	 * collected by the setter methods of this class. Each instance of this
	 * class should only be used for one invocation of the command. Don't call
	 * this method twice on an instance.
	 *
	 * @return an object describing the result of this command
	 */
	public RebaseResult call() throws NoHeadException, RefNotFoundException,
			JGitInternalException, GitAPIException {
		RevCommit newHead = null;
		boolean lastStepWasForward = false;
		checkCallable();
		checkParameters();
		try {
			switch (operation) {
			case ABORT:
				try {
					return abort(new RebaseResult(Status.ABORTED));
				} catch (IOException ioe) {
					throw new JGitInternalException(ioe.getMessage(), ioe);
				}
			case SKIP:
				// fall through
			case CONTINUE:
				String upstreamCommitName = readFile(rebaseDir, ONTO);
				this.upstreamCommit = walk.parseCommit(repo
						.resolve(upstreamCommitName));
				break;
			case BEGIN:
				RebaseResult res = initFilesAndRewind();
				if (res != null)
					return res;
			}

			if (monitor.isCancelled())
				return abort(new RebaseResult(Status.ABORTED));

			if (operation == Operation.CONTINUE)
				newHead = continueRebase();

			if (operation == Operation.SKIP)
				newHead = checkoutCurrentHead();

			ObjectReader or = repo.newObjectReader();

			List<Step> steps = loadSteps();
			for (Step step : steps) {
				popSteps(1);
				Collection<ObjectId> ids = or.resolve(step.commit);
				if (ids.size() != 1)
					throw new JGitInternalException(
							"Could not resolve uniquely the abbreviated object ID");
				RevCommit commitToPick = walk
						.parseCommit(ids.iterator().next());
				if (monitor.isCancelled())
					return new RebaseResult(commitToPick);
				try {
					monitor.beginTask(MessageFormat.format(
							JGitText.get().applyingCommit,
							commitToPick.getShortMessage()),
							ProgressMonitor.UNKNOWN);
					// if the first parent of commitToPick is the current HEAD,
					// we do a fast-forward instead of cherry-pick to avoid
					// unnecessary object rewriting
					newHead = tryFastForward(commitToPick);
					lastStepWasForward = newHead != null;
					if (!lastStepWasForward) {
						// TODO if the content of this commit is already merged
						// here we should skip this step in order to avoid
						// confusing pseudo-changed
						CherryPickResult cherryPickResult = new Git(repo)
								.cherryPick().include(commitToPick).call();
						switch (cherryPickResult.getStatus()) {
						case FAILED:
							if (operation == Operation.BEGIN)
								return abort(new RebaseResult(
										cherryPickResult.getFailingPaths()));
							else
								return stop(commitToPick);
						case CONFLICTING:
							return stop(commitToPick);
						case OK:
							newHead = cherryPickResult.getNewHead();
						}
					}
				} finally {
					monitor.endTask();
				}
			}
			if (newHead != null) {
				// point the previous head (if any) to the new commit
				String headName = readFile(rebaseDir, HEAD_NAME);
				if (headName.startsWith(Constants.R_REFS)) {
					RefUpdate rup = repo.updateRef(headName);
					rup.setNewObjectId(newHead);
					Result res = rup.forceUpdate();
					switch (res) {
					case FAST_FORWARD:
					case FORCED:
					case NO_CHANGE:
						break;
					default:
						throw new JGitInternalException("Updating HEAD failed");
					}
					rup = repo.updateRef(Constants.HEAD);
					res = rup.link(headName);
					switch (res) {
					case FAST_FORWARD:
					case FORCED:
					case NO_CHANGE:
						break;
					default:
						throw new JGitInternalException("Updating HEAD failed");
					}
				}
				FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);
				if (lastStepWasForward)
					return new RebaseResult(Status.FAST_FORWARD);
				return new RebaseResult(Status.OK);
			}
			return new RebaseResult(Status.UP_TO_DATE);
		} catch (IOException ioe) {
			throw new JGitInternalException(ioe.getMessage(), ioe);
		}
	}

