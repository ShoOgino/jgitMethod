	/**
	 * Executes the {@code Rebase} command with all the options and parameters
	 * collected by the setter methods of this class. Each instance of this
	 * class should only be used for one invocation of the command. Don't call
	 * this method twice on an instance.
	 *
	 * @return an object describing the result of this command
	 */
	public RebaseResult call() throws NoHeadException, RefNotFoundException,
			JGitInternalException, GitAPIException {
		RevCommit newHead = null;
		checkCallable();
		checkParameters();
		try {
			switch (operation) {
			case ABORT:
				try {
					return abort();
				} catch (IOException ioe) {
					throw new JGitInternalException(ioe.getMessage(), ioe);
				}
			case SKIP:
				// fall through
			case CONTINUE:
				String upstreamCommitName = readFile(rebaseDir, ONTO);
				this.upstreamCommit = walk.parseCommit(repo
						.resolve(upstreamCommitName));
				break;
			case BEGIN:
				RebaseResult res = initFilesAndRewind();
				if (res != null)
					return res;
			}

			if (monitor.isCancelled())
				return abort();

			if (this.operation == Operation.CONTINUE)
				newHead = continueRebase();

			if (this.operation == Operation.SKIP)
				newHead = checkoutCurrentHead();

			ObjectReader or = repo.newObjectReader();

			List<Step> steps = loadSteps();
			for (Step step : steps) {
				popSteps(1);
				Collection<ObjectId> ids = or.resolve(step.commit);
				if (ids.size() != 1)
					throw new JGitInternalException(
							"Could not resolve uniquely the abbreviated object ID");
				RevCommit commitToPick = walk
						.parseCommit(ids.iterator().next());
				if (monitor.isCancelled())
					return new RebaseResult(commitToPick);
				monitor.beginTask(MessageFormat.format(
						JGitText.get().applyingCommit, commitToPick
								.getShortMessage()), ProgressMonitor.UNKNOWN);
				// TODO if the first parent of commitToPick is the current HEAD,
				// we should fast-forward instead of cherry-pick to avoid
				// unnecessary object rewriting
				newHead = new Git(repo).cherryPick().include(commitToPick)
						.call();
				monitor.endTask();
				if (newHead == null) {
					return stop(commitToPick);
				}
			}
			if (newHead != null) {
				// point the previous head (if any) to the new commit
				String headName = readFile(rebaseDir, HEAD_NAME);
				if (headName.startsWith(Constants.R_REFS)) {
					RefUpdate rup = repo.updateRef(headName);
					rup.setNewObjectId(newHead);
					Result res = rup.forceUpdate();
					switch (res) {
					case FAST_FORWARD:
					case FORCED:
					case NO_CHANGE:
						break;
					default:
						throw new JGitInternalException("Updating HEAD failed");
					}
					rup = repo.updateRef(Constants.HEAD);
					res = rup.link(headName);
					switch (res) {
					case FAST_FORWARD:
					case FORCED:
					case NO_CHANGE:
						break;
					default:
						throw new JGitInternalException("Updating HEAD failed");
					}
				}
				FileUtils.delete(rebaseDir, FileUtils.RECURSIVE);
				return new RebaseResult(Status.OK);
			}
			return new RebaseResult(Status.UP_TO_DATE);
		} catch (IOException ioe) {
			throw new JGitInternalException(ioe.getMessage(), ioe);
		}
	}

