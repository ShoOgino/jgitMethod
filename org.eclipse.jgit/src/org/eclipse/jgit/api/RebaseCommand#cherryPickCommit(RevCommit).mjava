	private RebaseResult cherryPickCommit(RevCommit commitToPick)
			throws IOException, GitAPIException, NoMessageException,
			UnmergedPathsException, ConcurrentRefUpdateException,
			WrongRepositoryStateException, NoHeadException {
		try {
			monitor.beginTask(MessageFormat.format(
					JGitText.get().applyingCommit,
					commitToPick.getShortMessage()), ProgressMonitor.UNKNOWN);
			// if the first parent of commitToPick is the current HEAD,
			// we do a fast-forward instead of cherry-pick to avoid
			// unnecessary object rewriting
			newHead = tryFastForward(commitToPick);
			lastStepWasForward = newHead != null;
			if (!lastStepWasForward) {
				// TODO if the content of this commit is already merged
				// here we should skip this step in order to avoid
				// confusing pseudo-changed
				String ourCommitName = getOurCommitName();
				CherryPickResult cherryPickResult = new Git(repo).cherryPick()
						.include(commitToPick).setOurCommitName(ourCommitName)
						.setReflogPrefix("rebase:").call(); //$NON-NLS-1$
				switch (cherryPickResult.getStatus()) {
				case FAILED:
					if (operation == Operation.BEGIN)
						return abort(RebaseResult.failed(cherryPickResult
								.getFailingPaths()));
					else
						return stop(commitToPick, Status.STOPPED);
				case CONFLICTING:
					return stop(commitToPick, Status.STOPPED);
				case OK:
					newHead = cherryPickResult.getNewHead();
				}
			}
			return null;
		} finally {
			monitor.endTask();
		}
	}

