	public Collection<Ref> call() throws Exception {
		checkCallable();

		try {
			Transport transport = Transport.open(repo, remote);
			transport.setOptionUploadPack(uploadPack);

			try {
				Collection<RefSpec> refSpecs = new ArrayList<RefSpec>(1);
				if (tags) {
					refSpecs.add(new RefSpec(
							"refs/tags/*:refs/remotes/origin/tags/*"));
				}
				if (heads) {
					refSpecs.add(new RefSpec(
							"refs/heads/*:refs/remotes/origin/*"));
				}
				Collection<Ref> refs;
				Map<String, Ref> refmap = new HashMap<String, Ref>();
				FetchConnection fc = transport.openFetch();
				try {
					refs = fc.getRefs();
					for (Ref r : refs) {
						boolean found = refSpecs.isEmpty();
						for (RefSpec rs : refSpecs) {
							if (rs.matchSource(r)) {
								found = true;
								break;
							}
						}
						if (found) {
							refmap.put(r.getName(), r);
						}

					}
				} finally {
					fc.close();
				}
				return refmap.values();

			} catch (TransportException e) {
				throw new JGitInternalException(
						JGitText.get().exceptionCaughtDuringExecutionOfLsRemoteCommand,
						e);
			} finally {
				transport.close();
			}
		} catch (URISyntaxException e) {
			throw new InvalidRemoteException(MessageFormat.format(
					JGitText.get().invalidRemote, remote));
		} catch (NotSupportedException e) {
			throw new JGitInternalException(
					JGitText.get().exceptionCaughtDuringExecutionOfLsRemoteCommand,
					e);
		}
	}

