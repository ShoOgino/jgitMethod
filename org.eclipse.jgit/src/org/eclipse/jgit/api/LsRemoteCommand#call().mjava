	/**
	 * Executes the {@code LsRemote} command with all the options and parameters
	 * collected by the setter methods (e.g. {@link #setHeads(boolean)}) of this
	 * class. Each instance of this class should only be used for one invocation
	 * of the command. Don't call this method twice on an instance.
	 *
	 * @return a collection of references in the remote repository
	 * @throws InvalidRemoteException
	 *             when called with an invalid remote uri
	 * @throws JGitInternalException
	 *             a low-level exception of JGit has occurred. The original
	 *             exception can be retrieved by calling
	 *             {@link Exception#getCause()}.
	 */
	public Collection<Ref> call() throws GitAPIException,
			JGitInternalException {
		checkCallable();

		Transport transport = null;
		FetchConnection fc = null;
		try {
			transport = Transport.open(repo, remote);
			transport.setOptionUploadPack(uploadPack);
			configure(transport);
			Collection<RefSpec> refSpecs = new ArrayList<RefSpec>(1);
			if (tags)
				refSpecs.add(new RefSpec(
						"refs/tags/*:refs/remotes/origin/tags/*"));
			if (heads)
				refSpecs.add(new RefSpec("refs/heads/*:refs/remotes/origin/*"));
			Collection<Ref> refs;
			Map<String, Ref> refmap = new HashMap<String, Ref>();
			fc = transport.openFetch();
			refs = fc.getRefs();
			if (refSpecs.isEmpty())
				for (Ref r : refs)
					refmap.put(r.getName(), r);
			else
				for (Ref r : refs)
					for (RefSpec rs : refSpecs)
						if (rs.matchSource(r)) {
							refmap.put(r.getName(), r);
							break;
						}
			return refmap.values();
		} catch (URISyntaxException e) {
			throw new InvalidRemoteException(MessageFormat.format(
					JGitText.get().invalidRemote, remote));
		} catch (IOException e) {
			throw new JGitInternalException(
					JGitText.get().exceptionCaughtDuringExecutionOfLsRemoteCommand,
					e);
		} finally {
			if (fc != null)
				fc.close();
			if (transport != null)
				transport.close();
		}
	}

