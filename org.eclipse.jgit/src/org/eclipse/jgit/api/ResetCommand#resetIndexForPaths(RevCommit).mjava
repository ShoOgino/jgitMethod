	private void resetIndexForPaths(RevCommit commit) {
		DirCache dc = null;
		final DirCacheEditor edit;
		try {
			dc = repo.lockDirCache();
			edit = dc.editor();

			final TreeWalk tw = new TreeWalk(repo);
			tw.addTree(new DirCacheIterator(dc));
			tw.addTree(commit.getTree());
			tw.setFilter(PathFilterGroup.createFromStrings(filepaths));
			tw.setRecursive(true);

			while (tw.next()) {
				final String path = tw.getPathString();
				// DirCacheIterator dci = tw.getTree(0, DirCacheIterator.class);
				final CanonicalTreeParser tree = tw.getTree(1,
						CanonicalTreeParser.class);
				if (tree == null)
					// file is not in the commit, remove from index
					edit.add(new DirCacheEditor.DeletePath(path));
				else { // revert index to commit
					// it seams that there is concurrent access to tree
					// variable, therefore we need to keep references to
					// entryFileMode and entryObjectId in local
					// variables
					final FileMode entryFileMode = tree.getEntryFileMode();
					final ObjectId entryObjectId = tree.getEntryObjectId();
					edit.add(new DirCacheEditor.PathEdit(path) {
						@Override
						public void apply(DirCacheEntry ent) {
							ent.setFileMode(entryFileMode);
							ent.setObjectId(entryObjectId);
							ent.setLastModified(0);
						}
					});
				}
			}

			edit.commit();
		} catch (IOException e) {
			throw new RuntimeException(e);
		} finally {
			if (dc != null)
				dc.unlock();
		}
	}

