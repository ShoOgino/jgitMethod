	/**
	 * Executes the {@code push} command with all the options and parameters
	 * collected by the setter methods of this class. Each instance of this
	 * class should only be used for one invocation of the command (means: one
	 * call to {@link #call()})
	 *
	 * @return an iteration over {@link PushResult} objects
	 * @throws InvalidRemoteException
	 *             when called with an invalid remote uri
	 * @throws JGitInternalException
	 *             a low-level exception of JGit has occurred. The original
	 *             exception can be retrieved by calling
	 *             {@link Exception#getCause()}.
	 */
	public Iterable<PushResult> call() throws JGitInternalException,
			InvalidRemoteException {
		checkCallable();

		ArrayList<PushResult> pushResults = new ArrayList<PushResult>(3);

		try {
			if (force) {
				final List<RefSpec> orig = new ArrayList<RefSpec>(refSpecs);
				refSpecs.clear();
				for (final RefSpec spec : orig)
					refSpecs.add(spec.setForceUpdate(true));
			}

			final List<Transport> transports;
			transports = Transport.openAll(repo, remote, Transport.Operation.PUSH);
			for (final Transport transport : transports) {
				if (0 <= timeout)
					transport.setTimeout(timeout);
				transport.setPushThin(thin);
				if (receivePack != null)
					transport.setOptionReceivePack(receivePack);
				transport.setDryRun(dryRun);
				transport.setCredentialsProvider(credentialsProvider);

				final Collection<RemoteRefUpdate> toPush = transport
						.findRemoteRefUpdatesFor(refSpecs);

				try {
					PushResult result = transport.push(monitor, toPush);
					pushResults.add(result);

				} catch (TransportException e) {
					throw new JGitInternalException(
							JGitText.get().exceptionCaughtDuringExecutionOfPushCommand,
							e);
				} finally {
					transport.close();
				}
			}

		} catch (URISyntaxException e) {
			throw new InvalidRemoteException(MessageFormat.format(
					JGitText.get().invalidRemote, remote));
		} catch (NotSupportedException e) {
			throw new JGitInternalException(
					JGitText.get().exceptionCaughtDuringExecutionOfPushCommand,
					e);
		} catch (IOException e) {
			throw new JGitInternalException(
					JGitText.get().exceptionCaughtDuringExecutionOfPushCommand,
					e);
		}

		return pushResults;

	}

