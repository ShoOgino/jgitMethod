	/**
	 * Executes the {@code revert} command with all the options and parameters
	 * collected by the setter methods (e.g. {@link #include(Ref)} of this
	 * class. Each instance of this class should only be used for one invocation
	 * of the command. Don't call this method twice on an instance.
	 *
	 * @return on success the {@link RevCommit} pointed to by the new HEAD is
	 *         returned. If a failure occurred during revert <code>null</code>
	 *         is returned. The list of successfully reverted {@link Ref}'s can
	 *         be obtained by calling {@link #getRevertedRefs()}
	 */
	public RevCommit call() throws GitAPIException {
		RevCommit newHead = null;
		checkCallable();

		RevWalk revWalk = new RevWalk(repo);
		try {

			// get the head commit
			Ref headRef = repo.getRef(Constants.HEAD);
			if (headRef == null)
				throw new NoHeadException(
						JGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);
			RevCommit headCommit = revWalk.parseCommit(headRef.getObjectId());

			newHead = headCommit;

			// loop through all refs to be reverted
			for (Ref src : commits) {
				// get the commit to be reverted
				// handle annotated tags
				ObjectId srcObjectId = src.getPeeledObjectId();
				if (srcObjectId == null)
					srcObjectId = src.getObjectId();
				RevCommit srcCommit = revWalk.parseCommit(srcObjectId);

				// get the parent of the commit to revert
				if (srcCommit.getParentCount() != 1) {
					throw new MultipleParentsNotAllowedException(
							JGitText.get().canOnlyRevertCommitsWithOneParent);
				}
				RevCommit srcParent = srcCommit.getParent(0);
				revWalk.parseHeaders(srcParent);

				ResolveMerger merger = (ResolveMerger) MergeStrategy.RESOLVE
						.newMerger(repo);
				merger.setWorkingTreeIterator(new FileTreeIterator(repo));
				merger.setBase(srcCommit.getTree());

				if (merger.merge(headCommit, srcParent)) {
					if (AnyObjectId.equals(headCommit.getTree().getId(), merger
							.getResultTreeId()))
						continue;
					DirCacheCheckout dco = new DirCacheCheckout(repo,
							headCommit.getTree(), repo.lockDirCache(),
							merger.getResultTreeId());
					dco.setFailOnConflict(true);
					dco.checkout();
					String shortMessage = "Revert \"" + srcCommit.getShortMessage() + "\"";
					String newMessage = shortMessage + "\n\n"
							+ "This reverts commit "
							+ srcCommit.getId().getName() + ".\n";
					newHead = new Git(getRepository()).commit()
							.setMessage(newMessage)
							.setReflogComment("revert: " + shortMessage).call();
					revertedRefs.add(src);
				} else {
					Map<String, MergeFailureReason> failingPaths = merger
							.getFailingPaths();
					if (failingPaths != null)
						failingResult = new MergeResult(null,
								merger.getBaseCommit(0, 1),
								new ObjectId[] { headCommit.getId(),
										srcParent.getId() },
								MergeStatus.FAILED, MergeStrategy.RESOLVE,
								merger.getMergeResults(), failingPaths, null);
					return null;
				}
			}
		} catch (IOException e) {
			throw new JGitInternalException(
					MessageFormat.format(
									JGitText.get().exceptionCaughtDuringExecutionOfRevertCommand,
							e), e);
		} finally {
			revWalk.release();
		}
		return newHead;
	}

