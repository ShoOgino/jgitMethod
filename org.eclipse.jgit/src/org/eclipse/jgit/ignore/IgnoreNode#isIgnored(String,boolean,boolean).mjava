	/**
	 * Determine if an entry path matches an ignore rule.
	 *
	 * @param entryPath
	 *            the path to test. The path must be relative to this ignore
	 *            node's own repository path, and in repository path format
	 *            (uses '/' and not '\').
	 * @param isDirectory
	 *            true if the target item is a directory.
	 * @param negateFirstMatch
	 *            true if the first match should be negated
	 * @return status of the path.
	 * @since 3.6
	 */
	public MatchResult isIgnored(String entryPath, boolean isDirectory,
			boolean negateFirstMatch) {
		if (rules.isEmpty())
			if (negateFirstMatch)
				return MatchResult.CHECK_PARENT_NEGATE_FIRST_MATCH;
			else
				return MatchResult.CHECK_PARENT;

		// Parse rules in the reverse order that they were read
		for (int i = rules.size() - 1; i > -1; i--) {
			FastIgnoreRule rule = rules.get(i);
			if (rule.isMatch(entryPath, isDirectory)) {
				if (rule.getResult()) {
					// rule matches: path could be ignored
					if (negateFirstMatch)
						// ignore current match, reset "negate" flag, continue
						negateFirstMatch = false;
					else
						// valid match, just return
						return MatchResult.IGNORED;
				} else {
					// found negated rule
					if (negateFirstMatch)
						// not possible to re-include excluded ignore rule
						return MatchResult.NOT_IGNORED;
					else
						// set the flag and continue
						negateFirstMatch = true;
				}
			}
		}
		if (negateFirstMatch)
			// negated rule found but there is no previous rule in *this* file
			return MatchResult.CHECK_PARENT_NEGATE_FIRST_MATCH;
		// *this* file has no matching rules
		return MatchResult.CHECK_PARENT;
	}

