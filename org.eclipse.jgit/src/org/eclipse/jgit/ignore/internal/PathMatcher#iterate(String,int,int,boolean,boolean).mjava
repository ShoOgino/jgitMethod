	private boolean iterate(final String path, final int startIncl,
			final int endExcl, boolean assumeDirectory, boolean pathMatch) {
		int matcher = 0;
		int right = startIncl;
		boolean match = false;
		int lastWildmatch = -1;
		while (true) {
			int left = right;
			right = path.indexOf(slash, right);
			if (right == -1) {
				if (left < endExcl) {
					match = matches(matcher, path, left, endExcl,
							assumeDirectory);
				} else {
					// a/** should not match a/ or a
					match = match && matchers.get(matcher) != WILD;
				}
				if (match) {
					if (matcher < matchers.size() - 1
							&& matchers.get(matcher) == WILD) {
						// ** can match *nothing*: a/**/b match also a/b
						matcher++;
						match = matches(matcher, path, left, endExcl,
								assumeDirectory);
					} else if (dirOnly && !assumeDirectory) {
						// Directory expectations not met
						return false;
					}
				}
				return match && matcher + 1 == matchers.size();
			}
			if (right - left > 0) {
				match = matches(matcher, path, left, right, assumeDirectory);
			} else {
				// path starts with slash???
				right++;
				continue;
			}
			if (match) {
				boolean wasWild = matchers.get(matcher) == WILD;
				if (wasWild) {
					lastWildmatch = matcher;
					// ** can match *nothing*: a/**/b match also a/b
					right = left - 1;
				}
				matcher++;
				if (matcher == matchers.size()) {
					// We had a prefix match here.
					if (!pathMatch) {
						return true;
					} else {
						if (right == endExcl - 1) {
							// Extra slash at the end: actually a full match.
							// Must meet directory expectations
							return !dirOnly || assumeDirectory;
						}
						// Prefix matches only if pattern ended with /**
						return wasWild;
					}
				}
			} else if (lastWildmatch != -1) {
				matcher = lastWildmatch + 1;
			} else {
				return false;
			}
			right++;
		}
	}

