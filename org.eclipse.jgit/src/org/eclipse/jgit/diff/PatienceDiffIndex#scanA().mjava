	/**
	 * Index elements in sequence A for later matching.
	 *
	 * This is the second stage of preparing an index to find the longest common
	 * sequence. The state requires {@link #scanB()} to have been invoked first.
	 *
	 * Each element of A in the range [ptr, end) are searched for in the
	 * internal hashtable, to see if B has already registered a location.
	 *
	 * If prior matches were given in the constructor, these may be used to
	 * fast-forward through sections of A to avoid unnecessary recomputation.
	 */
	private void scanA() {
		int ptr = region.beginA;
		final int end = region.endA;
		int pLast = pBegin - 1;
		SCAN: while (ptr < end) {
			final int tIdx = cmp.hash(a, ptr) & tableMask;

			for (int eIdx = table[tIdx]; eIdx != 0; eIdx = next[eIdx]) {
				final long rec = ptrs[eIdx];
				final int bs = bOf(rec);

				if (isDuplicate(rec) || !cmp.equals(a, ptr, b, bs))
					continue;

				final int aPtr = aOfRaw(rec);
				if (aPtr != 0 && cmp.equals(a, ptr, a, aPtr - 1)) {
					ptrs[eIdx] = rec | A_DUPLICATE;
					uniqueCommonCnt--;
					ptr++;
					continue SCAN;
				}

				// This element is both common and unique. Link the
				// two sequences together at this point.
				//
				ptrs[eIdx] = rec | (((long) (ptr + 1)) << A_SHIFT);
				uniqueCommonCnt++;

				if (pBegin < pEnd) {
					// If we have prior match point data, we might be able
					// to locate the length of the match and skip past all
					// of those elements. We try to take advantage of the
					// fact that pCommon is sorted by B, and its likely that
					// matches in A appear in the same order as they do in B.
					//
					for (int pIdx = pLast + 1;; pIdx++) {
						if (pIdx == pEnd)
							pIdx = pBegin;
						else if (pIdx == pLast)
							break;

						final long priorRec = pCommon[pIdx];
						final int priorB = bOf(priorRec);
						if (bs < priorB)
							break;
						if (bs == priorB) {
							ptr += aOfRaw(priorRec) - priorB;
							pLast = pIdx;
							continue SCAN;
						}
					}
				}

				ptr++;
				continue SCAN;
			}

			ptr++;
		}
	}

