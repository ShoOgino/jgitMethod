	private FormatResult createFormatResult(DiffEntry ent) throws IOException,
			CorruptObjectException, MissingObjectException {
		final FormatResult res = new FormatResult();
		ByteArrayOutputStream buf = new ByteArrayOutputStream();
		final EditList editList;
		final FileHeader.PatchType type;

		formatHeader(buf, ent);

		if (ent.getOldMode() == GITLINK || ent.getNewMode() == GITLINK) {
			formatOldNewPaths(buf, ent);
			writeGitLinkDiffText(buf, ent);
			editList = new EditList();
			type = PatchType.UNIFIED;

		} else {
			if (db == null)
				throw new IllegalStateException(
						JGitText.get().repositoryIsRequired);

			ObjectReader reader = db.newObjectReader();
			byte[] aRaw, bRaw;
			try {
				aRaw = open(reader, //
						ent.getOldPath(), //
						ent.getOldMode(), //
						ent.getOldId());
				bRaw = open(reader, //
						ent.getNewPath(), //
						ent.getNewMode(), //
						ent.getNewId());
			} finally {
				reader.release();
			}

			if (aRaw == BINARY || bRaw == BINARY //
					|| RawText.isBinary(aRaw) || RawText.isBinary(bRaw)) {
				formatOldNewPaths(buf, ent);
				buf.write(encodeASCII("Binary files differ\n"));
				editList = new EditList();
				type = PatchType.BINARY;

			} else {
				res.a = rawTextFactory.create(aRaw);
				res.b = rawTextFactory.create(bRaw);
				editList = new MyersDiff(res.a, res.b).getEdits();
				type = PatchType.UNIFIED;

				switch (ent.getChangeType()) {
				case RENAME:
				case COPY:
					if (!editList.isEmpty())
						formatOldNewPaths(buf, ent);
					break;

				default:
					formatOldNewPaths(buf, ent);
					break;
				}
			}
		}

		res.header = new FileHeader(buf.toByteArray(), editList, type);
		return res;
	}

