	/**
	 * Index elements in sequence B for later matching with sequence A.
	 *
	 * This is the first stage of preparing an index to find the longest common
	 * sequence. Elements of sequence B in the range [ptr, end) are scanned in
	 * order and added to the internal hashtable.
	 *
	 * If prior matches were given in the constructor, these may be used to
	 * fast-forward through sections of B to avoid unnecessary recomputation.
	 */
	private void scanB() {
		// We insert in ascending order so that a later scan of the table
		// from 0 through entryCnt will iterate through B in order. This
		// is the desired result ordering from match().
		//
		int ptr = region.beginB;
		final int end = region.endB;
		int pIdx = pBegin;
		SCAN: while (ptr < end) {
			final int tIdx = cmp.hash(b, ptr) & tableMask;

			if (pIdx < pEnd) {
				final long priorRec = pCommon[pIdx];
				if (ptr == bOf(priorRec)) {
					// We know this region is unique from a prior pass.
					// Insert the start point, and skip right to the end.
					//
					insertB(tIdx, ptr);
					pIdx++;
					ptr = aOfRaw(priorRec);
					continue SCAN;
				}
			}

			// We aren't sure what the status of this element is. Add
			// it to our hashtable, and flag it as duplicate if there
			// was already a different entry present.
			//
			for (int eIdx = table[tIdx]; eIdx != 0; eIdx = next[eIdx]) {
				final long rec = ptrs[eIdx];
				if (cmp.equals(b, ptr, b, bOf(rec))) {
					ptrs[eIdx] = rec | B_DUPLICATE;
					ptr++;
					continue SCAN;
				}
			}

			insertB(tIdx, ptr);
			ptr++;
		}
	}

