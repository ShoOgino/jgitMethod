	/**
	 * Scan all potential matches and find the longest common sequence.
	 *
	 * If this method returns non-null, the caller should copy out the
	 * {@link #nCommon} array and pass that through to the recursive sub-steps
	 * so that existing common matches can be reused rather than recomputed.
	 *
	 * @return an edit covering the longest common sequence. Null if there are
	 *         no common unique sequences present.
	 */
	Edit findLongestCommonSequence() {
		scanB();
		scanA();

		if (uniqueCommonCnt == 0)
			return null;

		nCommon = new long[uniqueCommonCnt];
		int pIdx = pBegin;
		Edit lcs = new Edit(0, 0);

		MATCH: for (int eIdx = 1; eIdx <= entryCnt; eIdx++) {
			final long rec = ptrs[eIdx];
			if (isDuplicate(rec) || aOfRaw(rec) == 0)
				continue;

			int bs = bOf(rec);
			if (bs < lcs.endB)
				continue;

			int as = aOf(rec);
			if (pIdx < pEnd) {
				final long priorRec = pCommon[pIdx];
				if (bs == bOf(priorRec)) {
					// We had a prior match and we know its unique.
					// Reuse its region rather than computing again.
					//
					int be = aOfRaw(priorRec);

					if (lcs.getLengthB() < be - bs) {
						as -= bOf(rec) - bs;
						lcs.beginA = as;
						lcs.beginB = bs;
						lcs.endA = as + (be - bs);
						lcs.endB = be;
						cIdx = nCnt;
					}

					nCommon[nCnt] = priorRec;
					if (++nCnt == uniqueCommonCnt)
						break MATCH;

					pIdx++;
					continue MATCH;
				}
			}

			// We didn't have prior match data, or this is the first time
			// seeing this particular pair. Extend the region as large as
			// possible and remember it for future use.
			//
			int ae = as + 1;
			int be = bs + 1;

			while (region.beginA < as && region.beginB < bs
					&& cmp.equals(a, as - 1, b, bs - 1)) {
				as--;
				bs--;
			}
			while (ae < region.endA && be < region.endB
					&& cmp.equals(a, ae, b, be)) {
				ae++;
				be++;
			}

			if (lcs.getLengthB() < be - bs) {
				lcs.beginA = as;
				lcs.beginB = bs;
				lcs.endA = ae;
				lcs.endB = be;
				cIdx = nCnt;
			}

			nCommon[nCnt] = (((long) bs) << B_SHIFT) | (((long) be) << A_SHIFT);
			if (++nCnt == uniqueCommonCnt)
				break MATCH;
		}

		return lcs;
	}

