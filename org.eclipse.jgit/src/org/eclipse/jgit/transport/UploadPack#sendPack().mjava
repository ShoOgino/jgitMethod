	private void sendPack() throws IOException {
		final boolean thin = options.contains(OPTION_THIN_PACK);
		final boolean progress = !options.contains(OPTION_NO_PROGRESS);
		final boolean sideband = options.contains(OPTION_SIDE_BAND)
				|| options.contains(OPTION_SIDE_BAND_64K);

		ProgressMonitor pm = NullProgressMonitor.INSTANCE;
		OutputStream packOut = rawOut;

		if (sideband) {
			int bufsz = SideBandOutputStream.SMALL_BUF;
			if (options.contains(OPTION_SIDE_BAND_64K))
				bufsz = SideBandOutputStream.MAX_BUF;

			packOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,
					bufsz, rawOut);
			if (progress)
				pm = new SideBandProgressMonitor(new SideBandOutputStream(
						SideBandOutputStream.CH_PROGRESS, bufsz, rawOut));
		}

		final PackWriter pw;
		pw = new PackWriter(db);
		try {
			pw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));
			pw.setThin(thin);
			pw.preparePack(pm, wantAll, commonBase);
			if (options.contains(OPTION_INCLUDE_TAG)) {
				for (final Ref r : refs.values()) {
					final RevObject o;
					try {
						o = walk.parseAny(r.getObjectId());
					} catch (IOException e) {
						continue;
					}
					if (o.has(WANT) || !(o instanceof RevTag))
						continue;
					final RevTag t = (RevTag) o;
					if (!pw.willInclude(t) && pw.willInclude(t.getObject()))
						pw.addObject(t);
				}
			}
			pw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);
		} finally {
			pw.release();
		}
		packOut.flush();

		if (sideband)
			pckOut.end();
	}

