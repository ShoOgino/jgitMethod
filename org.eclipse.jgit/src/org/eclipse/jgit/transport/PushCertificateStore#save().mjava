	/**
	 * Save pending certificates to the store.
	 * <p>
	 * One commit is created per certificate added with {@link
	 * #put(PushCertificate, PersonIdent)}, in order of identity timestamps, and
	 * a single ref update is performed.
	 * <p>
	 * The pending list is cleared if and only the ref update fails, which allows
	 * for easy retries in case of lock failure.
	 *
	 * @return the result of attempting to update the ref.
	 * @throws IOException
	 *             if there was an error reading from or writing to the
	 *             repository.
	 */
	public RefUpdate.Result save() throws IOException {
		if (pending.isEmpty()) {
			return RefUpdate.Result.NO_CHANGE;
		}
		if (reader == null) {
			load();
		}
		sortPending(pending);

		ObjectId curr = commit;
		DirCache dc = newDirCache();
		try (ObjectInserter inserter = db.newObjectInserter()) {
			for (PendingCert pc : pending) {
				curr = saveCert(inserter, dc, pc, curr);
			}
			inserter.flush();
			RefUpdate.Result result = updateRef(curr);
			switch (result) {
				case FAST_FORWARD:
				case NEW:
				case NO_CHANGE:
					pending.clear();
					break;
				default:
					break;
			}
			return result;
		} finally {
			close();
		}
	}

