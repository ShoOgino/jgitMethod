		void execute() throws IOException {
			out.close();

			if (conn == null) {
				// Output hasn't started yet, because everything fit into
				// our request buffer. Send with a Content-Length header.
				//
				if (out.length() == 0) {
					throw new TransportException(uri,
							JGitText.get().startingReadStageWithoutWrittenRequestDataPendingIsNotSupported);
				}

				// Try to compress the content, but only if that is smaller.
				TemporaryBuffer buf = new TemporaryBuffer.Heap(http.postBuffer);
				try {
					GZIPOutputStream gzip = new GZIPOutputStream(buf);
					out.writeTo(gzip, null);
					gzip.close();
					if (out.length() < buf.length())
						buf = out;
				} catch (IOException err) {
					// Most likely caused by overflowing the buffer, meaning
					// its larger if it were compressed. Don't compress.
					buf = out;
				}

				openStream();
				if (buf != out)
					conn.setRequestProperty(HDR_CONTENT_ENCODING, ENCODING_GZIP);
				conn.setFixedLengthStreamingMode((int) buf.length());
				final OutputStream httpOut = conn.getOutputStream();
				try {
					buf.writeTo(httpOut, null);
				} finally {
					httpOut.close();
				}
			}

			out.reset();

			final int status = HttpSupport.response(conn);
			if (status != HttpURLConnection.HTTP_OK) {
				throw new TransportException(uri, status + " " //$NON-NLS-1$
						+ conn.getResponseMessage());
			}

			final String contentType = conn.getContentType();
			if (!responseType.equals(contentType)) {
				conn.getInputStream().close();
				throw wrongContentType(responseType, contentType);
			}

			in.add(openInputStream(conn));
			in.add(execute);
			conn = null;
		}

