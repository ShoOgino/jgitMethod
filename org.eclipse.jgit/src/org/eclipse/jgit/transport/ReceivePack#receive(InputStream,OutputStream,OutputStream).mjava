	/**
	 * Execute the receive task on the socket.
	 *
	 * @param input
	 *            raw input to read client commands and pack data from. Caller
	 *            must ensure the input is buffered, otherwise read performance
	 *            may suffer.
	 * @param output
	 *            response back to the Git network client. Caller must ensure
	 *            the output is buffered, otherwise write performance may
	 *            suffer.
	 * @param messages
	 *            secondary "notice" channel to send additional messages out
	 *            through. When run over SSH this should be tied back to the
	 *            standard error channel of the command execution. For most
	 *            other network connections this should be null.
	 * @throws IOException
	 */
	public void receive(final InputStream input, final OutputStream output,
			final OutputStream messages) throws IOException {
		try {
			rawIn = input;
			rawOut = output;

			if (timeout > 0) {
				final Thread caller = Thread.currentThread();
				timer = new InterruptTimer(caller.getName() + "-Timer");
				timeoutIn = new TimeoutInputStream(rawIn, timer);
				TimeoutOutputStream o = new TimeoutOutputStream(rawOut, timer);
				timeoutIn.setTimeout(timeout * 1000);
				o.setTimeout(timeout * 1000);
				rawIn = timeoutIn;
				rawOut = o;
			}

			pckIn = new PacketLineIn(rawIn);
			pckOut = new PacketLineOut(rawOut);
			if (messages != null)
				msgs = new OutputStreamWriter(messages, Constants.CHARSET);

			enabledCapablities = new HashSet<String>();
			commands = new ArrayList<ReceiveCommand>();

			service();
		} finally {
			walk.release();
			try {
				if (pckOut != null)
					pckOut.flush();
				if (msgs != null)
					msgs.flush();

				if (sideBand) {
					// If we are using side band, we need to send a final
					// flush-pkt to tell the remote peer the side band is
					// complete and it should stop decoding. We need to
					// use the original output stream as rawOut is now the
					// side band data channel.
					//
					new PacketLineOut(output).end();
				}
			} finally {
				unlockPack();
				timeoutIn = null;
				rawIn = null;
				rawOut = null;
				pckIn = null;
				pckOut = null;
				msgs = null;
				refs = null;
				enabledCapablities = null;
				commands = null;
				if (timer != null) {
					try {
						timer.terminate();
					} finally {
						timer = null;
					}
				}
			}
		}
	}

