	private void resolveDeltas(DeltaVisit visit, final int type)
			throws IOException {
		do {
			final long pos = visit.delta.position;
			crc.reset();
			position(pos);
			int c = readFrom(Source.FILE);
			final int typeCode = (c >> 4) & 7;
			long sz = c & 15;
			int shift = 4;
			while ((c & 0x80) != 0) {
				c = readFrom(Source.FILE);
				sz += (c & 0x7f) << shift;
				shift += 7;
			}

			switch (typeCode) {
			case Constants.OBJ_OFS_DELTA: {
				c = readFrom(Source.FILE) & 0xff;
				while ((c & 128) != 0)
					c = readFrom(Source.FILE) & 0xff;
				visit.data = BinaryDelta.apply(visit.parent.data, inflateAndReturn(Source.FILE, sz));
				break;
			}
			case Constants.OBJ_REF_DELTA: {
				crc.update(buf, fill(Source.FILE, 20), 20);
				use(20);
				visit.data = BinaryDelta.apply(visit.parent.data, inflateAndReturn(Source.FILE, sz));
				break;
			}
			default:
				throw new IOException(MessageFormat.format(JGitText.get().unknownObjectType, typeCode));
			}

			final int crc32 = (int) crc.getValue();
			if (visit.delta.crc != crc32)
				throw new IOException(MessageFormat.format(JGitText.get().corruptionDetectedReReadingAt, pos));

			objectDigest.update(Constants.encodedTypeString(type));
			objectDigest.update((byte) ' ');
			objectDigest.update(Constants.encodeASCII(visit.data.length));
			objectDigest.update((byte) 0);
			objectDigest.update(visit.data);
			tempObjectId.fromRaw(objectDigest.digest(), 0);

			verifySafeObject(tempObjectId, type, visit.data);

			PackedObjectInfo oe;
			oe = new PackedObjectInfo(pos, crc32, tempObjectId);
			addObjectAndTrack(oe);

			visit.nextChild = firstChildOf(oe);
			visit = visit.next();
		} while (visit != null);
	}

