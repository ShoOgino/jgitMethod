	private void verifyLooseObject(final AnyObjectId id, final byte[] compressed)
			throws IOException {
		final UnpackedObjectLoader uol;
		try {
			uol = new UnpackedObjectLoader(compressed);
		} catch (CorruptObjectException parsingError) {
			// Some HTTP servers send back a "200 OK" status with an HTML
			// page that explains the requested file could not be found.
			// These servers are most certainly misconfigured, but many
			// of them exist in the world, and many of those are hosting
			// Git repositories.
			//
			// Since an HTML page is unlikely to hash to one of our loose
			// objects we treat this condition as a FileNotFoundException
			// and attempt to recover by getting the object from another
			// source.
			//
			final FileNotFoundException e;
			e = new FileNotFoundException(id.name());
			e.initCause(parsingError);
			throw e;
		}

		objectDigest.reset();
		objectDigest.update(Constants.encodedTypeString(uol.getType()));
		objectDigest.update((byte) ' ');
		objectDigest.update(Constants.encodeASCII(uol.getSize()));
		objectDigest.update((byte) 0);
		objectDigest.update(uol.getCachedBytes());
		idBuffer.fromRaw(objectDigest.digest(), 0);

		if (!AnyObjectId.equals(id, idBuffer)) {
			throw new TransportException(MessageFormat.format(JGitText.get().incorrectHashFor
					, id.name(), idBuffer.name(), Constants.typeString(uol.getType()), compressed.length));
		}
		if (objCheck != null) {
			try {
				objCheck.check(uol.getType(), uol.getCachedBytes());
			} catch (CorruptObjectException e) {
				throw new TransportException(MessageFormat.format(JGitText.get().transportExceptionInvalid
						, Constants.typeString(uol.getType()), id.name(), e.getMessage()));
			}
		}
	}

