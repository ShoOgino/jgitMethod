	/*
	 * Determines what "shallow" and "unshallow" lines to send to the user.
	 * The information is written to shallowCommits (if not null) and
	 * unshallowCommits, and also written to #pckOut (if writeToPckOut is
	 * true).
	 */
	private void processShallow(@Nullable List<ObjectId> shallowCommits,
			List<ObjectId> unshallowCommits,
			boolean writeToPckOut) throws IOException {
		if (options.contains(OPTION_DEEPEN_RELATIVE) ||
				shallowSince != 0 ||
				!shallowExcludeRefs.isEmpty()) {
			// TODO(jonathantanmy): Implement deepen-relative, deepen-since,
			// and deepen-not.
			throw new UnsupportedOperationException();
		}

		int walkDepth = depth - 1;
		try (DepthWalk.RevWalk depthWalk = new DepthWalk.RevWalk(
				walk.getObjectReader(), walkDepth)) {

			// Find all the commits which will be shallow
			for (ObjectId o : wantIds) {
				try {
					depthWalk.markRoot(depthWalk.parseCommit(o));
				} catch (IncorrectObjectTypeException notCommit) {
					// Ignore non-commits in this loop.
				}
			}

			RevCommit o;
			while ((o = depthWalk.next()) != null) {
				DepthWalk.Commit c = (DepthWalk.Commit) o;

				// Commits at the boundary which aren't already shallow in
				// the client need to be marked as such
				if (c.getDepth() == walkDepth
						&& !clientShallowCommits.contains(c)) {
					if (shallowCommits != null) {
						shallowCommits.add(c.copy());
					}
					if (writeToPckOut) {
						pckOut.writeString("shallow " + o.name()); //$NON-NLS-1$
					}
				}

				// Commits not on the boundary which are shallow in the client
				// need to become unshallowed
				if (c.getDepth() < walkDepth
						&& clientShallowCommits.remove(c)) {
					unshallowCommits.add(c.copy());
					if (writeToPckOut) {
						pckOut.writeString("unshallow " + c.name()); //$NON-NLS-1$
					}
				}
			}
		}
		if (writeToPckOut) {
			pckOut.end();
		}
	}

