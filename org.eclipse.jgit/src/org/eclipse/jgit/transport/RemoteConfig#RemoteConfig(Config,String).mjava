	/**
	 * Parse a remote block from an existing configuration file.
	 * <p>
	 * This constructor succeeds even if the requested remote is not defined
	 * within the supplied configuration file. If that occurs then there will be
	 * no URIs and no ref specifications known to the new instance.
	 *
	 * @param rc
	 *            the existing configuration to get the remote settings from.
	 *            The configuration must already be loaded into memory.
	 * @param remoteName
	 *            subsection key indicating the name of this remote.
	 * @throws URISyntaxException
	 *             one of the URIs within the remote's configuration is invalid.
	 */
	public RemoteConfig(final Config rc, final String remoteName)
			throws URISyntaxException {
		name = remoteName;

		String[] vlst;
		String val;

		vlst = rc.getStringList(SECTION, name, KEY_URL);
		Map<String, String> insteadOf = getReplacements(rc, KEY_INSTEADOF);
		uris = new ArrayList<>(vlst.length);
		for (final String s : vlst) {
			uris.add(new URIish(replaceUri(s, insteadOf)));
		}
		Map<String, String> pushInsteadOf = getReplacements(rc,
				KEY_PUSHINSTEADOF);
		String[] plst = rc.getStringList(SECTION, name, KEY_PUSHURL);
		pushURIs = new ArrayList<>(plst.length);
		for (final String s : plst) {
			pushURIs.add(new URIish(replaceUri(s, pushInsteadOf)));
		}
		if (pushURIs.isEmpty() && !pushInsteadOf.isEmpty()) {
			// Would default to the uris. If we have pushinsteadof, we must
			// supply rewritten push uris.
			for (String s : vlst) {
				String replaced = replaceUri(s, pushInsteadOf);
				if (!s.equals(replaced)) {
					pushURIs.add(new URIish(replaced));
				}
			}
		}
		vlst = rc.getStringList(SECTION, name, KEY_FETCH);
		fetch = new ArrayList<>(vlst.length);
		for (final String s : vlst)
			fetch.add(new RefSpec(s));

		vlst = rc.getStringList(SECTION, name, KEY_PUSH);
		push = new ArrayList<>(vlst.length);
		for (final String s : vlst)
			push.add(new RefSpec(s));

		val = rc.getString(SECTION, name, KEY_UPLOADPACK);
		if (val == null)
			val = DEFAULT_UPLOAD_PACK;
		uploadpack = val;

		val = rc.getString(SECTION, name, KEY_RECEIVEPACK);
		if (val == null)
			val = DEFAULT_RECEIVE_PACK;
		receivepack = val;

		val = rc.getString(SECTION, name, KEY_TAGOPT);
		tagopt = TagOpt.fromOption(val);
		mirror = rc.getBoolean(SECTION, name, KEY_MIRROR, DEFAULT_MIRROR);
		timeout = rc.getInt(SECTION, name, KEY_TIMEOUT, 0);
	}

