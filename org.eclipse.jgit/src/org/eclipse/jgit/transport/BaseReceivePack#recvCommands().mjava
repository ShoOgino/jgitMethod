	/**
	 * Receive a list of commands from the input.
	 *
	 * @throws IOException
	 */
	protected void recvCommands() throws IOException {
		for (;;) {
			String rawLine;
			try {
				rawLine = pckIn.readStringRaw();
			} catch (EOFException eof) {
				if (commands.isEmpty())
					return;
				throw eof;
			}
			if (rawLine == PacketLineIn.END) {
				break;
			}
			String line = chomp(rawLine);

			if (line.length() >= 48 && line.startsWith("shallow ")) { //$NON-NLS-1$
				clientShallowCommits.add(ObjectId.fromString(line.substring(8, 48)));
				continue;
			}

			if (commands.isEmpty()) {
				final FirstLine firstLine = new FirstLine(line);
				enabledCapabilities = firstLine.getCapabilities();
				line = firstLine.getLine();

				if (line.equals(GitProtocolConstants.OPTION_PUSH_CERT))
					pushCertificateParser.receiveHeader(pckIn,
							!isBiDirectionalPipe());
			}

			if (line.equals(PushCertificateParser.BEGIN_SIGNATURE)) {
				pushCertificateParser.receiveSignature(pckIn);
			}

			if (line.length() < 83) {
				final String m = JGitText.get().errorInvalidProtocolWantedOldNewRef;
				sendError(m);
				throw new PackProtocolException(m);
			}

			final ReceiveCommand cmd = parseCommand(line);
			if (cmd.getRefName().equals(Constants.HEAD)) {
				cmd.setResult(Result.REJECTED_CURRENT_BRANCH);
			} else {
				cmd.setRef(refs.get(cmd.getRefName()));
			}
			commands.add(cmd);
			if (pushCertificateParser.enabled()) {
				// Must use raw line with optional newline so signed payload can be
				// reconstructed.
				pushCertificateParser.addCommand(cmd, rawLine);
			}
		}
	}

