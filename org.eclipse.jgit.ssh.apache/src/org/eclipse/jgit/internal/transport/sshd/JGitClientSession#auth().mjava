	@Override
	public AuthFuture auth() throws IOException {
		if (getUsername() == null) {
			throw new IllegalStateException(
					SshdText.get().sessionWithoutUsername);
		}
		ClientUserAuthService authService = getUserAuthService();
		String serviceName = nextServiceName();
		List<Throwable> errors = null;
		AuthFuture future;
		// Guard both getting early errors and setting authFuture
		synchronized (errorLock) {
			future = authService.auth(serviceName);
			if (future == null) {
				// Internal error; no translation.
				throw new IllegalStateException(
						"No auth future generated by service '" //$NON-NLS-1$
								+ serviceName + '\'');
			}
			errors = earlyErrors;
			earlyErrors = null;
			authFuture = future;
		}
		if (errors != null && !errors.isEmpty()) {
			Iterator<Throwable> iter = errors.iterator();
			Throwable first = iter.next();
			iter.forEachRemaining(t -> {
				if (t != first && t != null) {
					first.addSuppressed(t);
				}
			});
			// Mark the future as having had an exception; just to be on the
			// safe side. Actually, there shouldn't be anyone waiting on this
			// future yet.
			future.setException(first);
			if (log.isDebugEnabled()) {
				log.debug("auth({}) early exception type={}: {}", //$NON-NLS-1$
						this, first.getClass().getSimpleName(),
						first.getMessage());
			}
			if (first instanceof SshException) {
				throw new SshException(
						((SshException) first).getDisconnectCode(),
						first.getMessage(), first);
			}
			throw new IOException(first.getMessage(), first);
		}
		return future;
	}

