	@Test
	public void testRacyGitDetection() throws Exception {
		TreeSet<Long> modTimes = new TreeSet<>();
		File lastFile;

		// Reset to force creation of index file
		try (Git git = new Git(db)) {
			git.reset().call();
		}

		// wait to ensure that modtimes of the file doesn't match last index
		// file modtime
		modTimes.add(valueOf(fsTick(db.getIndexFile())));

		// create two files
		addToWorkDir("a", "a");
		lastFile = addToWorkDir("b", "b");

		// wait to ensure that file-modTimes and therefore index entry modTime
		// doesn't match the modtime of index-file after next persistance
		modTimes.add(valueOf(fsTick(lastFile)));

		// now add both files to the index. No racy git expected
		resetIndex(new FileTreeIteratorWithTimeControl(db, modTimes));

		assertEquals(
				"[a, mode:100644, time:t0, length:1, content:a]" +
				"[b, mode:100644, time:t0, length:1, content:b]",
				indexState(SMUDGE | MOD_TIME | LENGTH | CONTENT));

		// Remember the last modTime of index file. All modifications times of
		// further modification are translated to this value so it looks that
		// files have been modified in the same time slot as the index file
		long indexMod = db.getIndexFile().lastModified();
		modTimes.add(Long.valueOf(indexMod));

		// modify one file
		long aMod = addToWorkDir("a", "a2").lastModified();
		assumeTrue(aMod == indexMod);

		// now update the index the index. 'a' has to be racily clean -- because
		// it's modification time is exactly the same as the previous index file
		// mod time.
		resetIndex(new FileTreeIteratorWithTimeControl(db, modTimes));

		db.readDirCache();
		// although racily clean a should not be reported as being dirty
		assertEquals(
				"[a, mode:100644, time:t1, smudged, length:0, content:a2]" +
				"[b, mode:100644, time:t0, length:1, content:b]",
				indexState(SMUDGE|MOD_TIME|LENGTH|CONTENT));
	}

