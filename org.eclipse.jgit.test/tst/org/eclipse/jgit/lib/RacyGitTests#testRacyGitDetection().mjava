	@Test
	public void testRacyGitDetection() throws Exception {
		// Reset to force creation of index file
		try (Git git = new Git(db)) {
			git.reset().call();
		}

		// wait to ensure that modtimes of the file doesn't match last index
		// file modtime
		fsTick(db.getIndexFile());

		// create two files
		File a = addToWorkDir("a", "a");
		File b = addToWorkDir("b", "b");
		assertTrue(a.setLastModified(b.lastModified()));
		assertTrue(b.setLastModified(b.lastModified()));

		// wait to ensure that file-modTimes and therefore index entry modTime
		// doesn't match the modtime of index-file after next persistance
		fsTick(b);

		// now add both files to the index. No racy git expected
		resetIndex(new FileTreeIterator(db));

		assertEquals(
				"[a, mode:100644, time:t0, length:1, content:a]"
						+ "[b, mode:100644, time:t0, length:1, content:b]",
				indexState(SMUDGE | MOD_TIME | LENGTH | CONTENT));

		// wait to ensure the file 'a' is updated at t1.
		fsTick(db.getIndexFile());

		// Create a racy git situation. This is a situation that the index is
		// updated and then a file is modified within a second. By changing the
		// index file artificially, we create a fake racy situation.
		File updatedA = addToWorkDir("a", "a2");
		assertTrue(updatedA.setLastModified(updatedA.lastModified() + 100));
		resetIndex(new FileTreeIterator(db));
		assertTrue(db.getIndexFile()
				.setLastModified(updatedA.lastModified() + 90));

		db.readDirCache();
		// although racily clean a should not be reported as being dirty
		assertEquals(
				"[a, mode:100644, time:t1, smudged, length:0, content:a2]"
						+ "[b, mode:100644, time:t0, length:1, content:b]",
				indexState(SMUDGE | MOD_TIME | LENGTH | CONTENT));
	}

