	/**
	 * Rebase topic onto master, not rewriting E. The merge resulting in D is
	 * confliicting to show that the manual merge resolution survives the
	 * rebase.
	 *
	 * <pre>
	 * A - B - G (master)
	 *  \   \
	 *   \   C - D - F (topic)
	 *    \     /
	 *      E (side)
	 * </pre>
	 *
	 * <pre>
	 * A - B - G (master)
	 *  \       \
	 *   \       C' - D' - F' (topic')
	 *    \          /
	 *      E (side)
	 * </pre>
	 *
	 * @param testConflict
	 * @throws Exception
	 */
	private void doTestRebasePreservingMergesWithUnrelatedSide(
			boolean testConflict) throws Exception {
		RevWalk rw = new RevWalk(db);
		rw.sort(RevSort.TOPO);

		writeTrashFile(FILE1, FILE1);
		git.add().addFilepattern(FILE1).call();
		RevCommit a = git.commit().setMessage("commit a").call();

		writeTrashFile("file2", "blah");
		git.add().addFilepattern("file2").call();
		RevCommit b = git.commit().setMessage("commit b").call();

		// create a topic branch
		createBranch(b, "refs/heads/topic");
		checkoutBranch("refs/heads/topic");

		writeTrashFile("file3", "more changess");
		writeTrashFile(FILE1, "preparing conflict");
		git.add().addFilepattern("file3").addFilepattern(FILE1).call();
		RevCommit c = git.commit().setMessage("commit c").call();

		createBranch(a, "refs/heads/side");
		checkoutBranch("refs/heads/side");
		writeTrashFile("conflict", "e");
		writeTrashFile(FILE1, FILE1 + "\n" + "line 2");
		git.add().addFilepattern(".").call();
		RevCommit e = git.commit().setMessage("commit e").call();

		// switch back to topic and merge in side, creating d
		checkoutBranch("refs/heads/topic");
		MergeResult result = git.merge().include(e)
				.setStrategy(MergeStrategy.RESOLVE).call();

		assertEquals(MergeStatus.CONFLICTING, result.getMergeStatus());
		assertEquals(result.getConflicts().keySet(),
				Collections.singleton(FILE1));
		writeTrashFile(FILE1, "merge resolution");
		git.add().addFilepattern(FILE1).call();
		RevCommit d = git.commit().setMessage("commit d").call();

		RevCommit f = commitFile("file2", "new content two", "topic");

		checkoutBranch("refs/heads/master");
		writeTrashFile("fileg", "fileg");
		if (testConflict)
			writeTrashFile("conflict", "g");
		git.add().addFilepattern(".").call();
		RevCommit g = git.commit().setMessage("commit g").call();

		checkoutBranch("refs/heads/topic");
		RebaseResult res = git.rebase().setUpstream("refs/heads/master")
				.setPreserveMerges(true).call();
		if (testConflict) {
			assertEquals(Status.STOPPED, res.getStatus());
			assertEquals(Collections.singleton("conflict"), git.status().call()
					.getConflicting());
			// resolve
			writeTrashFile("conflict", "e");
			git.add().addFilepattern("conflict").call();
			res = git.rebase().setOperation(Operation.CONTINUE).call();
		}
		assertEquals(Status.OK, res.getStatus());

		assertEquals("merge resolution", read(FILE1));
		assertEquals("new content two", read("file2"));
		assertEquals("more changess", read("file3"));
		assertEquals("fileg", read("fileg"));

		rw.markStart(rw.parseCommit(db.resolve("refs/heads/topic")));
		RevCommit newF = rw.next();
		assertDerivedFrom(newF, f);
		RevCommit newD = rw.next();
		assertDerivedFrom(newD, d);
		assertEquals(2, newD.getParentCount());
		RevCommit newC = rw.next();
		assertDerivedFrom(newC, c);
		RevCommit newE = rw.next();
		assertEquals(e, newE);
		assertEquals(newC, newD.getParent(0));
		assertEquals(e, newD.getParent(1));
		assertEquals(g, rw.next());
		assertEquals(b, rw.next());
		assertEquals(a, rw.next());
	}

