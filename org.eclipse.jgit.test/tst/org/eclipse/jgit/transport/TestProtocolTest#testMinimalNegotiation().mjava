	@Test
	public void testMinimalNegotiation() throws Exception {
		TestProtocol<User> proto = registerDefault();
		URIish uri = proto.register(new User("user"), remote.getRepository());

		// Enough local branches to cause 10 rounds of negotiation,
		// and a unique remote master branch commit with a later timestamp.
		for (int i = 0; i < 10 * HAVES_PER_ROUND; i++) {
			local.branch("local-branch-" + i).commit().create();
		}
		remote.tick(11 * HAVES_PER_ROUND);
		RevCommit master = remote.branch("master").commit()
				.add("readme.txt", "unique commit").create();

		TestProtocol.setFetchConfig(new FetchConfig(true, true));
		try (Git git = new Git(local.getRepository())) {
			assertNull(local.getRepository().exactRef("refs/heads/master"));
			git.fetch().setRemote(uri.toString()).setRefSpecs(MASTER).call();
			assertEquals(master, local.getRepository()
					.exactRef("refs/heads/master").getObjectId());
			assertTrue(havesCount <= 2 * HAVES_PER_ROUND);

			// Update the remote master and add local branches for 5 more rounds
			// of negotiation, where the local branch commits have newer
			// timestamps. Negotiation should send 5 rounds for those newer
			// branches before getting to the round that sends its stale version
			// of master.
			master = remote.branch("master").commit().parent(master).create();
			local.tick(2 * HAVES_PER_ROUND);
			for (int i = 0; i < 5 * HAVES_PER_ROUND; i++) {
				local.branch("local-" + i).commit().create();
			}
			git.fetch().setRemote(uri.toString()).setRefSpecs(MASTER).call();
			assertEquals(master, local.getRepository()
					.exactRef("refs/heads/master").getObjectId());
			assertEquals(6 * HAVES_PER_ROUND, havesCount);
		}
	}

