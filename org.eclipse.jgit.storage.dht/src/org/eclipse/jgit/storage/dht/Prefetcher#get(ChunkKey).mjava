	synchronized PackChunk get(ChunkKey key) throws DhtException {
		GET: for (;;) {
			if (error != null)
				throw error;

			Status chunkStatus = status.get(key);
			if (chunkStatus == null)
				return null;

			switch (chunkStatus) {
			case ON_QUEUE:
				if (queue.isEmpty()) {
					// Should never happen, but let the caller load.
					status.put(key, Status.DONE);
					return null;

				} else if (bytesReady + bytesLoading < highWaterMark) {
					// Make sure its first in the queue, start, and wait.
					if (!queue.getFirst().equals(key)) {
						int idx = queue.indexOf(key);
						if (first && objectType == OBJ_COMMIT) {
							// If the prefetcher has not started yet, skip all
							// chunks up to this first request. Assume this
							// initial out-of-order get occurred because the
							// RevWalk has already parsed all of the commits
							// up to this point and does not need them again.
							//
							for (; 0 < idx; idx--)
								status.put(queue.removeFirst(), Status.DONE);
							forceStartGet();
							continue GET;
						}

						stats.access(key).cntPrefetcher_OutOfOrder++;
						queue.remove(idx);
						queue.addFirst(key);
					}
					forceStartGet();
					continue GET;

				} else {
					// It cannot be moved up to the front of the queue
					// without violating the prefetch size. Let the
					// caller load the chunk out of order.
					stats.access(key).cntPrefetcher_OutOfOrder++;
					status.put(key, Status.DONE);
					return null;
				}

			case LOADING: // Wait for a prefetch that is already started.
				status.put(key, Status.WAITING);
				//$FALL-THROUGH$
			case WAITING:
				stats.access(key).cntPrefetcher_WaitedForLoad++;
				try {
					wait();
				} catch (InterruptedException e) {
					throw new DhtTimeoutException(e);
				}
				continue GET;

			case READY:
				return useReadyChunk(key);

			case DONE:
				stats.access(key).cntPrefetcher_Revisited++;
				return null;

			default:
				throw new IllegalStateException(key + " " + chunkStatus);
			}
		}
	}

