	private void copyPack(PackOutputStream out, DhtReader ctx,
			Prefetcher prefetcher, boolean validate) throws DhtException,
			DhtMissingChunkException, IOException {
		Map<ChunkKey, Long> startsAt = new HashMap<ChunkKey, Long>();
		for (ChunkKey key : info.chunks) {
			PackChunk chunk = prefetcher.get(key);

			// The prefetcher should always produce the chunk for us, if not
			// there is something seriously wrong with the ordering or
			// within the prefetcher code and aborting is more sane than
			// using slow synchronous lookups.
			//
			if (chunk == null)
				throw new DhtMissingChunkException(key);

			// Verify each long OFS_DELTA chunk appears at the right offset.
			// This is a cheap validation that the cached pack hasn't been
			// incorrectly created and would confuse the client.
			//
			long position = out.length();
			if (chunk.getMeta() != null && chunk.getMeta().baseChunks != null) {
				for (ChunkMeta.BaseChunk base : chunk.getMeta().baseChunks) {
					Long act = startsAt.get(base.getChunkKey());
					long exp = position - base.getRelativeStart();

					if (act == null) {
						throw new DhtException(MessageFormat.format(DhtText
								.get().wrongChunkPositionInCachedPack, info
								.getRowKey(), base.getChunkKey(),
								"[not written]", key, exp));
					}

					if (act.longValue() != exp) {
						throw new DhtException(MessageFormat.format(DhtText
								.get().wrongChunkPositionInCachedPack, info
								.getRowKey(), base.getChunkKey(), //
								act, key, exp));
					}
				}
			}

			startsAt.put(key, Long.valueOf(position));
			chunk.copyEntireChunkAsIs(out, null, validate);
		}
	}

