	private void copyPack(PackOutputStream out, Prefetcher prefetcher,
			boolean validate) throws DhtException, DhtMissingChunkException,
			IOException {
		Map<String, Long> startsAt = new HashMap<String, Long>();
		for (ChunkKey key : keyList) {
			PackChunk chunk = prefetcher.get(key);

			// The prefetcher should always produce the chunk for us, if not
			// there is something seriously wrong with the ordering or
			// within the prefetcher code and aborting is more sane than
			// using slow synchronous lookups.
			//
			if (chunk == null)
				throw new DhtMissingChunkException(key);

			// Verify each long OFS_DELTA chunk appears at the right offset.
			// This is a cheap validation that the cached pack hasn't been
			// incorrectly created and would confuse the client.
			//
			long position = out.length();
			ChunkMeta meta = chunk.getMeta();
			if (meta != null && meta.getBaseChunkCount() != 0) {
				for (ChunkMeta.BaseChunk base : meta.getBaseChunkList()) {
					Long act = startsAt.get(base.getChunkKey());
					long exp = position - base.getRelativeStart();

					if (act == null) {
						throw new DhtException(MessageFormat.format(DhtText
								.get().wrongChunkPositionInCachedPack,
								rowKey(), base.getChunkKey(),
								"[not written]", key, Long.valueOf(exp)));
					}

					if (act.longValue() != exp) {
						throw new DhtException(MessageFormat.format(DhtText
								.get().wrongChunkPositionInCachedPack,
								rowKey(), base.getChunkKey(),
								act, key, Long.valueOf(exp)));
					}
				}
			}

			startsAt.put(key.asString(), Long.valueOf(position));
			chunk.copyEntireChunkAsIs(out, null, validate);
		}
	}

