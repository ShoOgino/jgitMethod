	ChunkKey end(MessageDigest md) {
		if (md == null)
			md = Constants.newMessageDigest();

		// Embed a small amount of randomness into the chunk content,
		// and thus impact its name. This prevents malicious clients from
		// being able to predict what a chunk is called, which keeps them
		// from replacing an existing chunk.
		//
		chunkData = cloneArray(chunkData, ptr + TRAILER_SIZE);
		NB.encodeInt32(chunkData, ptr, options.nextChunkSalt());
		ptr += 4;

		md.update(chunkData, 0, ptr);
		ChunkKey key = ChunkKey.create(repo, ObjectId.fromRaw(md.digest()));

		GitStore.ChunkInfo.Builder info = GitStore.ChunkInfo.newBuilder();
		info.setSource(source);
		info.setObjectType(GitStore.ChunkInfo.ObjectType.valueOf(objectType));
		if (fragment)
			info.setIsFragment(true);
		info.setChunkSize(chunkData.length);

		GitStore.ChunkInfo.ObjectCounts.Builder cnts = info.getObjectCountsBuilder();
		cnts.setTotal(objectsTotal);
		if (objectsWhole > 0)
			cnts.setWhole(objectsWhole);
		if (objectsRefDelta > 0)
			cnts.setRefDelta(objectsRefDelta);
		if (objectsOfsDelta > 0)
			cnts.setOfsDelta(objectsOfsDelta);

		builder = new PackChunk.Members();
		builder.setChunkKey(key);
		builder.setChunkData(chunkData);

		if (baseChunks != null) {
			List<BaseChunk> list = new ArrayList<BaseChunk>(baseChunks.size());
			for (BaseChunkInfo b : baseChunks.values()) {
				if (0 < b.useCount) {
					BaseChunk.Builder c = BaseChunk.newBuilder();
					c.setRelativeStart(b.relativeStart);
					c.setChunkKey(b.key.asString());
					list.add(c.build());
				}
			}
			Collections.sort(list, new Comparator<BaseChunk>() {
				public int compare(BaseChunk a, BaseChunk b) {
					return Long.signum(a.getRelativeStart()
							- b.getRelativeStart());
				}
			});
			ChunkMeta.Builder b = ChunkMeta.newBuilder();
			b.addAllBaseChunk(list);
			ChunkMeta meta = b.build();
			builder.setMeta(meta);
			info.setMetaSize(meta.getSerializedSize());
		}

		if (objectList != null && !objectList.isEmpty()) {
			byte[] index = ChunkIndex.create(objectList);
			builder.setChunkIndex(index);
			info.setIndexSize(index.length);
		}

		chunkInfo = new ChunkInfo(key, info.build());
		return getChunkKey();
	}

