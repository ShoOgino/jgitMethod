	private void selectInBatches(Context options, Iterable<T> objects)
			throws DhtException {
		final int batchSize = reader.getOptions()
				.getObjectIndexBatchSize();

		Map<ObjectIndexKey, T> batch = new HashMap<ObjectIndexKey, T>();
		Iterator<T> otpItr = objects.iterator();
		while (otpItr.hasNext()) {
			T otp = otpItr.next();

			batch.put(ObjectIndexKey.create(repo, otp), otp);

			if (batch.size() < batchSize && otpItr.hasNext())
				continue;

			if (error.get() != null)
				break;

			try {
				if (progress != null) {
					while (!batches.tryAcquire(500, MILLISECONDS))
						progress.pollForUpdates();
					progress.pollForUpdates();
				} else {
					batches.acquire();
				}
			} catch (InterruptedException err) {
				error.compareAndSet(null, new DhtTimeoutException(err));
				break;
			}

			startQuery(options, batch);
			batch = new HashMap<ObjectIndexKey, T>();
		}

		try {
			if (progress != null) {
				while (!batches.tryAcquire(concurrentBatches, 500, MILLISECONDS))
					progress.pollForUpdates();
				progress.pollForUpdates();
			} else {
				batches.acquire(concurrentBatches);
			}
		} catch (InterruptedException err) {
			error.compareAndSet(null, new DhtTimeoutException(err));
		}

		if (error.get() != null)
			throw error.get();

		// Make sure retry changes are visible to us.
		resultLock.lock();
		resultLock.unlock();
	}

