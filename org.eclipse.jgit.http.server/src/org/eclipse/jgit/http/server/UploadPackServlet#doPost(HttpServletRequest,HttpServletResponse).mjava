	@Override
	public void doPost(final HttpServletRequest req,
			final HttpServletResponse rsp) throws IOException {
		if (!UPLOAD_PACK_REQUEST_TYPE.equals(req.getContentType())) {
			rsp.sendError(SC_UNSUPPORTED_MEDIA_TYPE);
			return;
		}

		int[] version = parseVersion(req.getHeader(HDR_USER_AGENT));
		if (hasChunkedEncodingRequestBug(version, req)) {
			GitSmartHttpTools.sendError(req, rsp, SC_BAD_REQUEST, "\n\n"
					+ HttpServerText.get().clientHas175ChunkedEncodingBug);
			return;
		}

		SmartOutputStream out = new SmartOutputStream(req, rsp, false) {
			@Override
			public void flush() throws IOException {
				doFlush();
			}
		};

		UploadPack up = (UploadPack) req.getAttribute(ATTRIBUTE_HANDLER);
		try {
			up.setBiDirectionalPipe(false);
			rsp.setContentType(UPLOAD_PACK_RESULT_TYPE);

			up.upload(getInputStream(req), out, null);
			out.close();

		} catch (ServiceMayNotContinueException e) {
			if (e.isOutput()) {
				consumeRequestBody(req);
				out.close();
			} else if (!rsp.isCommitted()) {
				rsp.reset();
				sendError(req, rsp, SC_FORBIDDEN, e.getMessage());
			}
			return;

		} catch (UploadPackInternalServerErrorException e) {
			// Special case exception, error message was sent to client.
			getServletContext().log(
					HttpServerText.get().internalErrorDuringUploadPack,
					e.getCause());
			consumeRequestBody(req);
			out.close();

		} catch (Throwable e) {
			getServletContext().log(HttpServerText.get().internalErrorDuringUploadPack, e);
			if (!rsp.isCommitted()) {
				rsp.reset();
				sendError(req, rsp, SC_INTERNAL_SERVER_ERROR);
			}
			return;
		}
	}

